/* unity-greeter.c generated by valac 0.30.1, the Vala compiler
 * generated from unity-greeter.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2011 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by: Robert Ancell <robert.ancell@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <cairo-xlib.h>
#include <gtk/gtk.h>
#include <lightdm.h>
#include <canberra.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gdk/gdkx.h>
#include <stdio.h>
#include <sys/mman.h>
#include <locale.h>
#include <glib/gi18n-lib.h>
#include "config.h"
#include "libido/libido.h"
#include <unistd.h>
#include <glib-unix.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <gobject/gvaluecollector.h>


#define TYPE_UNITY_GREETER (unity_greeter_get_type ())
#define UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNITY_GREETER, UnityGreeter))
#define UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNITY_GREETER, UnityGreeterClass))
#define IS_UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNITY_GREETER))
#define IS_UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNITY_GREETER))
#define UNITY_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNITY_GREETER, UnityGreeterClass))

typedef struct _UnityGreeter UnityGreeter;
typedef struct _UnityGreeterClass UnityGreeterClass;
typedef struct _UnityGreeterPrivate UnityGreeterPrivate;

#define TYPE_SETTINGS_DAEMON (settings_daemon_get_type ())
#define SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemon))
#define SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))
#define IS_SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_DAEMON))
#define IS_SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_DAEMON))
#define SETTINGS_DAEMON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))

typedef struct _SettingsDaemon SettingsDaemon;
typedef struct _SettingsDaemonClass SettingsDaemonClass;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;

#define TYPE_DIALOG_DBUS_INTERFACE (dialog_dbus_interface_get_type ())
#define DIALOG_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterface))
#define DIALOG_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterfaceClass))
#define IS_DIALOG_DBUS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIALOG_DBUS_INTERFACE))
#define IS_DIALOG_DBUS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIALOG_DBUS_INTERFACE))
#define DIALOG_DBUS_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIALOG_DBUS_INTERFACE, DialogDBusInterfaceClass))

typedef struct _DialogDBusInterface DialogDBusInterface;
typedef struct _DialogDBusInterfaceClass DialogDBusInterfaceClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_unref0(var) ((var == NULL) ? NULL : (var = (g_key_file_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _ca_context_destroy0(var) ((var == NULL) ? NULL : (var = (ca_context_destroy (var), NULL)))
#define _unity_greeter_unref0(var) ((var == NULL) ? NULL : (var = (unity_greeter_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_SHUTDOWN_DIALOG_TYPE (shutdown_dialog_type_get_type ())

#define TYPE_FADABLE_BOX (fadable_box_get_type ())
#define FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FADABLE_BOX, FadableBox))
#define FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FADABLE_BOX, FadableBoxClass))
#define IS_FADABLE_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FADABLE_BOX))
#define IS_FADABLE_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FADABLE_BOX))
#define FADABLE_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FADABLE_BOX, FadableBoxClass))

typedef struct _FadableBox FadableBox;
typedef struct _FadableBoxClass FadableBoxClass;

#define TYPE_GREETER_LIST (greeter_list_get_type ())
#define GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GREETER_LIST, GreeterList))
#define GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GREETER_LIST, GreeterListClass))
#define IS_GREETER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GREETER_LIST))
#define IS_GREETER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GREETER_LIST))
#define GREETER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GREETER_LIST, GreeterListClass))

typedef struct _GreeterList GreeterList;
typedef struct _GreeterListClass GreeterListClass;

#define TYPE_BACKGROUND (background_get_type ())
#define BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BACKGROUND, Background))
#define BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BACKGROUND, BackgroundClass))
#define IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BACKGROUND))
#define IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BACKGROUND))
#define BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BACKGROUND, BackgroundClass))

typedef struct _Background Background;
typedef struct _BackgroundClass BackgroundClass;

#define BACKGROUND_TYPE_DRAW_FLAGS (background_draw_flags_get_type ())
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_MENU_BAR (menu_bar_get_type ())
#define MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_BAR, MenuBar))
#define MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_BAR, MenuBarClass))
#define IS_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_BAR))
#define IS_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_BAR))
#define MENU_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_BAR, MenuBarClass))

typedef struct _MenuBar MenuBar;
typedef struct _MenuBarClass MenuBarClass;

#define TYPE_LIST_STACK (list_stack_get_type ())
#define LIST_STACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LIST_STACK, ListStack))
#define LIST_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LIST_STACK, ListStackClass))
#define IS_LIST_STACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LIST_STACK))
#define IS_LIST_STACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LIST_STACK))
#define LIST_STACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LIST_STACK, ListStackClass))

typedef struct _ListStack ListStack;
typedef struct _ListStackClass ListStackClass;
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
typedef struct _ParamSpecUnityGreeter ParamSpecUnityGreeter;
typedef struct _DialogDBusInterfacePrivate DialogDBusInterfacePrivate;

struct _UnityGreeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityGreeterPrivate * priv;
	gboolean test_mode;
	gboolean orca_needs_kick;
};

struct _UnityGreeterClass {
	GTypeClass parent_class;
	void (*finalize) (UnityGreeter *self);
};

struct _UnityGreeterPrivate {
	gchar* state_file;
	GKeyFile* state;
	cairo_surface_t* background_surface;
	SettingsDaemon* settings_daemon;
	MainWindow* main_window;
	LightDMGreeter* greeter;
	ca_context* canberra_context;
	DialogDBusInterface* dbus_object;
};

typedef enum  {
	SHUTDOWN_DIALOG_TYPE_LOGOUT,
	SHUTDOWN_DIALOG_TYPE_SHUTDOWN,
	SHUTDOWN_DIALOG_TYPE_RESTART
} ShutdownDialogType;

typedef enum  {
	BACKGROUND_DRAW_FLAGS_NONE,
	BACKGROUND_DRAW_FLAGS_GRID
} BackgroundDrawFlags;

struct _MainWindow {
	GtkWindow parent_instance;
	MainWindowPrivate * priv;
	MenuBar* menubar;
	ListStack* stack;
};

struct _MainWindowClass {
	GtkWindowClass parent_class;
};

struct _ParamSpecUnityGreeter {
	GParamSpec parent_instance;
};

struct _DialogDBusInterface {
	GObject parent_instance;
	DialogDBusInterfacePrivate * priv;
};

struct _DialogDBusInterfaceClass {
	GObjectClass parent_class;
};


static gpointer unity_greeter_parent_class = NULL;
extern UnityGreeter* unity_greeter_singleton;
UnityGreeter* unity_greeter_singleton = NULL;
static GTimer* unity_greeter_log_timer;
static GTimer* unity_greeter_log_timer = NULL;
static gpointer dialog_dbus_interface_parent_class = NULL;

#define grid_size 40
gpointer unity_greeter_ref (gpointer instance);
void unity_greeter_unref (gpointer instance);
GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_unity_greeter (GValue* value, gpointer v_object);
void value_take_unity_greeter (GValue* value, gpointer v_object);
gpointer value_get_unity_greeter (const GValue* value);
GType unity_greeter_get_type (void) G_GNUC_CONST;
GType settings_daemon_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
GType dialog_dbus_interface_get_type (void) G_GNUC_CONST;
guint dialog_dbus_interface_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
#define UNITY_GREETER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_UNITY_GREETER, UnityGreeterPrivate))
enum  {
	UNITY_GREETER_DUMMY_PROPERTY
};
static UnityGreeter* unity_greeter_new (gboolean test_mode_);
static UnityGreeter* unity_greeter_construct (GType object_type, gboolean test_mode_);
static cairo_surface_t* unity_greeter_create_root_surface (GdkScreen* screen);
static void __lambda57_ (UnityGreeter* self, const gchar* text, LightDMMessageType type);
static void ___lambda57__lightdm_greeter_show_message (LightDMGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self);
static void __lambda58_ (UnityGreeter* self, const gchar* text, LightDMPromptType type);
static void ___lambda58__lightdm_greeter_show_prompt (LightDMGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self);
static void __lambda59_ (UnityGreeter* self);
static void ___lambda59__lightdm_greeter_autologin_timer_expired (LightDMGreeter* _sender, gpointer self);
static void __lambda60_ (UnityGreeter* self);
static void ___lambda60__lightdm_greeter_authentication_complete (LightDMGreeter* _sender, gpointer self);
SettingsDaemon* settings_daemon_new (void);
SettingsDaemon* settings_daemon_construct (GType object_type);
void settings_daemon_start (SettingsDaemon* self);
MainWindow* main_window_new (void);
MainWindow* main_window_construct (GType object_type);
DialogDBusInterface* dialog_dbus_interface_new (void);
DialogDBusInterface* dialog_dbus_interface_construct (GType object_type);
static void __lambda61_ (UnityGreeter* self, guint32 type);
GType shutdown_dialog_type_get_type (void) G_GNUC_CONST;
void main_window_show_shutdown_dialog (MainWindow* self, ShutdownDialogType type);
static void ___lambda61__dialog_dbus_interface_open_dialog (DialogDBusInterface* _sender, guint32 type, gpointer self);
static void __lambda62_ (UnityGreeter* self, DialogDBusInterface* type);
void main_window_close_shutdown_dialog (MainWindow* self);
static void ___lambda62__dialog_dbus_interface_close_dialog (DialogDBusInterface* _sender, gpointer self);
static void __lambda63_ (UnityGreeter* self, GDBusConnection* c);
static void ___lambda63__gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void __lambda64_ (UnityGreeter* self);
static void ___lambda64__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void unity_greeter_start_fake_wm (UnityGreeter* self);
static gboolean unity_greeter_ready_cb (UnityGreeter* self);
static gboolean _unity_greeter_ready_cb_gsource_func (gpointer self);
gchar* unity_greeter_get_state (UnityGreeter* self, const gchar* key);
void unity_greeter_set_state (UnityGreeter* self, const gchar* key, const gchar* value);
GType fadable_box_get_type (void) G_GNUC_CONST;
GType greeter_list_get_type (void) G_GNUC_CONST;
void unity_greeter_push_list (UnityGreeter* self, GreeterList* widget);
void main_window_push_list (MainWindow* self, GreeterList* widget);
void unity_greeter_pop_list (UnityGreeter* self);
void main_window_pop_list (MainWindow* self);
void unity_greeter_add_style_class (GtkWidget* widget);
GType background_get_type (void) G_GNUC_CONST;
gboolean unity_greeter_start_session (UnityGreeter* self, const gchar* session, Background* bg);
GType background_draw_flags_get_type (void) G_GNUC_CONST;
void background_draw_full (Background* self, cairo_t* c, BackgroundDrawFlags flags);
static void unity_greeter_refresh_background (GdkScreen* screen, cairo_surface_t* surface);
static gboolean unity_greeter_session_is_valid (UnityGreeter* self, const gchar* session);
gboolean ug_settings_get_boolean (const gchar* key);
#define UG_SETTINGS_KEY_PLAY_READY_SOUND "play-ready-sound"
void unity_greeter_show (UnityGreeter* self);
void main_window_set_keyboard_state (MainWindow* self);
gboolean unity_greeter_is_authenticated (UnityGreeter* self);
void unity_greeter_authenticate (UnityGreeter* self, const gchar* userid);
void unity_greeter_authenticate_as_guest (UnityGreeter* self);
void unity_greeter_authenticate_remote (UnityGreeter* self, const gchar* session, const gchar* userid);
void unity_greeter_cancel_authentication (UnityGreeter* self);
void unity_greeter_respond (UnityGreeter* self, const gchar* response);
gchar* unity_greeter_authentication_user (UnityGreeter* self);
gchar* unity_greeter_default_session_hint (UnityGreeter* self);
gchar* unity_greeter_select_user_hint (UnityGreeter* self);
gboolean unity_greeter_show_manual_login_hint (UnityGreeter* self);
gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self);
gboolean unity_greeter_hide_users_hint (UnityGreeter* self);
gboolean unity_greeter_has_guest_account_hint (UnityGreeter* self);
static GdkFilterReturn unity_greeter_focus_upon_map (UnityGreeter* self, GdkXEvent* gxevent, GdkEvent* event);
GType menu_bar_get_type (void) G_GNUC_CONST;
GType list_stack_get_type (void) G_GNUC_CONST;
GtkWindow* menu_bar_get_keyboard_window (MenuBar* self);
static GdkFilterReturn _unity_greeter_focus_upon_map_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
static void unity_greeter_log_cb (const gchar* log_domain, GLogLevelFlags log_level, const gchar* message);
gint unity_greeter_main (gchar** args, int args_length1);
static void _unity_greeter_log_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
gchar* ug_settings_get_string (const gchar* key);
#define UG_SETTINGS_KEY_THEME_NAME "theme-name"
#define UG_SETTINGS_KEY_ICON_THEME_NAME "icon-theme-name"
#define UG_SETTINGS_KEY_FONT_NAME "font-name"
gdouble ug_settings_get_double (const gchar* key);
#define UG_SETTINGS_KEY_XFT_DPI "xft-dpi"
#define UG_SETTINGS_KEY_XFT_ANTIALIAS "xft-antialias"
#define UG_SETTINGS_KEY_XFT_HINTSTYLE "xft-hintstyle"
#define UG_SETTINGS_KEY_XFT_RGBA "xft-rgba"
static gboolean __lambda65_ (void);
static gboolean ___lambda65__gsource_func (gpointer self);
static void g_cclosure_user_marshal_VOID__STRING_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void unity_greeter_finalize (UnityGreeter* obj);
enum  {
	DIALOG_DBUS_INTERFACE_DUMMY_PROPERTY
};
void dialog_dbus_interface_open (DialogDBusInterface* self, guint32 type, guint32 timestamp, guint32 seconds_to_stay_open, char** inhibitor_object_paths, int inhibitor_object_paths_length1);
void dialog_dbus_interface_close (DialogDBusInterface* self);
static void _dbus_dialog_dbus_interface_open (DialogDBusInterface* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_dialog_dbus_interface_close (DialogDBusInterface* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void dialog_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* dialog_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean dialog_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_dialog_dbus_interface_open_dialog (GObject* _sender, guint32 type, gpointer* _data);
static void _dbus_dialog_dbus_interface_close_dialog (GObject* _sender, gpointer* _data);
static void _dialog_dbus_interface_unregister_object (gpointer user_data);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_type = {-1, "type", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_timestamp = {-1, "timestamp", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_seconds_to_stay_open = {-1, "seconds_to_stay_open", "u"};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_inhibitor_object_paths = {-1, "inhibitor_object_paths", "ao"};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_in[] = {&_dialog_dbus_interface_dbus_arg_info_open_type, &_dialog_dbus_interface_dbus_arg_info_open_timestamp, &_dialog_dbus_interface_dbus_arg_info_open_seconds_to_stay_open, &_dialog_dbus_interface_dbus_arg_info_open_inhibitor_object_paths, NULL};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_out[] = {NULL};
static const GDBusMethodInfo _dialog_dbus_interface_dbus_method_info_open = {-1, "Open", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_in), (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_out)};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_in[] = {NULL};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_out[] = {NULL};
static const GDBusMethodInfo _dialog_dbus_interface_dbus_method_info_close = {-1, "Close", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_in), (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_out)};
static const GDBusMethodInfo * const _dialog_dbus_interface_dbus_method_info[] = {&_dialog_dbus_interface_dbus_method_info_open, &_dialog_dbus_interface_dbus_method_info_close, NULL};
static const GDBusArgInfo _dialog_dbus_interface_dbus_arg_info_open_dialog_type = {-1, "type", "u"};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_open_dialog[] = {&_dialog_dbus_interface_dbus_arg_info_open_dialog_type, NULL};
static const GDBusSignalInfo _dialog_dbus_interface_dbus_signal_info_open_dialog = {-1, "OpenDialog", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_open_dialog)};
static const GDBusArgInfo * const _dialog_dbus_interface_dbus_arg_info_close_dialog[] = {NULL};
static const GDBusSignalInfo _dialog_dbus_interface_dbus_signal_info_close_dialog = {-1, "CloseDialog", (GDBusArgInfo **) (&_dialog_dbus_interface_dbus_arg_info_close_dialog)};
static const GDBusSignalInfo * const _dialog_dbus_interface_dbus_signal_info[] = {&_dialog_dbus_interface_dbus_signal_info_open_dialog, &_dialog_dbus_interface_dbus_signal_info_close_dialog, NULL};
static const GDBusPropertyInfo * const _dialog_dbus_interface_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _dialog_dbus_interface_dbus_interface_info = {-1, "org.gnome.SessionManager.EndSessionDialog", (GDBusMethodInfo **) (&_dialog_dbus_interface_dbus_method_info), (GDBusSignalInfo **) (&_dialog_dbus_interface_dbus_signal_info), (GDBusPropertyInfo **) (&_dialog_dbus_interface_dbus_property_info)};
static const GDBusInterfaceVTable _dialog_dbus_interface_dbus_interface_vtable = {dialog_dbus_interface_dbus_interface_method_call, dialog_dbus_interface_dbus_interface_get_property, dialog_dbus_interface_dbus_interface_set_property};

static gpointer _unity_greeter_ref0 (gpointer self) {
	return self ? unity_greeter_ref (self) : NULL;
}


static void __lambda57_ (UnityGreeter* self, const gchar* text, LightDMMessageType type) {
	const gchar* _tmp0_ = NULL;
	LightDMMessageType _tmp1_ = 0;
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = type;
	g_signal_emit_by_name (self, "show-message", _tmp0_, _tmp1_);
}


static void ___lambda57__lightdm_greeter_show_message (LightDMGreeter* _sender, const gchar* text, LightDMMessageType type, gpointer self) {
	__lambda57_ ((UnityGreeter*) self, text, type);
}


static void __lambda58_ (UnityGreeter* self, const gchar* text, LightDMPromptType type) {
	const gchar* _tmp0_ = NULL;
	LightDMPromptType _tmp1_ = 0;
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = type;
	g_signal_emit_by_name (self, "show-prompt", _tmp0_, _tmp1_);
}


static void ___lambda58__lightdm_greeter_show_prompt (LightDMGreeter* _sender, const gchar* text, LightDMPromptType type, gpointer self) {
	__lambda58_ ((UnityGreeter*) self, text, type);
}


static void __lambda59_ (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_authenticate_autologin (_tmp0_);
}


static void ___lambda59__lightdm_greeter_autologin_timer_expired (LightDMGreeter* _sender, gpointer self) {
	__lambda59_ ((UnityGreeter*) self);
}


static void __lambda60_ (UnityGreeter* self) {
	g_signal_emit_by_name (self, "authentication-complete");
}


static void ___lambda60__lightdm_greeter_authentication_complete (LightDMGreeter* _sender, gpointer self) {
	__lambda60_ ((UnityGreeter*) self);
}


static void __lambda61_ (UnityGreeter* self, guint32 type) {
	ShutdownDialogType dialog_type = 0;
	guint32 _tmp0_ = 0U;
	MainWindow* _tmp1_ = NULL;
	ShutdownDialogType _tmp2_ = 0;
	_tmp0_ = type;
	switch (_tmp0_) {
		default:
		case 1:
		{
			dialog_type = SHUTDOWN_DIALOG_TYPE_LOGOUT;
			break;
		}
		case 2:
		{
			dialog_type = SHUTDOWN_DIALOG_TYPE_RESTART;
			break;
		}
	}
	_tmp1_ = self->priv->main_window;
	_tmp2_ = dialog_type;
	main_window_show_shutdown_dialog (_tmp1_, _tmp2_);
}


static void ___lambda61__dialog_dbus_interface_open_dialog (DialogDBusInterface* _sender, guint32 type, gpointer self) {
	__lambda61_ ((UnityGreeter*) self, type);
}


static void __lambda62_ (UnityGreeter* self, DialogDBusInterface* type) {
	MainWindow* _tmp0_ = NULL;
	g_return_if_fail (type != NULL);
	_tmp0_ = self->priv->main_window;
	main_window_close_shutdown_dialog (_tmp0_);
}


static void ___lambda62__dialog_dbus_interface_close_dialog (DialogDBusInterface* _sender, gpointer self) {
	__lambda62_ ((UnityGreeter*) self, _sender);
}


static void __lambda63_ (UnityGreeter* self, GDBusConnection* c) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (c != NULL);
	{
		GDBusConnection* _tmp0_ = NULL;
		DialogDBusInterface* _tmp1_ = NULL;
		_tmp0_ = c;
		_tmp1_ = self->priv->dbus_object;
		dialog_dbus_interface_register_object (_tmp1_, _tmp0_, "/org/gnome/SessionManager/EndSessionDialog", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch33_g_error;
		}
	}
	goto __finally33;
	__catch33_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_warning ("unity-greeter.vala:131: Failed to register /org/gnome/SessionManager/E" \
"ndSessionDialog: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally33:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda63__gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda63_ ((UnityGreeter*) self, connection);
}


static void __lambda64_ (UnityGreeter* self) {
	g_debug ("unity-greeter.vala:135: Failed to acquire name com.canonical.Unity");
}


static void ___lambda64__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda64_ ((UnityGreeter*) self);
}


static gboolean _unity_greeter_ready_cb_gsource_func (gpointer self) {
	gboolean result;
	result = unity_greeter_ready_cb ((UnityGreeter*) self);
	return result;
}


static UnityGreeter* unity_greeter_construct (GType object_type, gboolean test_mode_) {
	UnityGreeter* self = NULL;
	UnityGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GdkScreen* _tmp2_ = NULL;
	cairo_surface_t* _tmp3_ = NULL;
	LightDMGreeter* _tmp4_ = NULL;
	LightDMGreeter* _tmp5_ = NULL;
	LightDMGreeter* _tmp6_ = NULL;
	LightDMGreeter* _tmp7_ = NULL;
	LightDMGreeter* _tmp8_ = NULL;
	gboolean connected = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp15_ = FALSE;
	gchar* state_dir = NULL;
	const gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	gchar* xdg_seat = NULL;
	const gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	gchar* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	const gchar* _tmp25_ = NULL;
	gchar* state_file_name = NULL;
	gchar* _tmp30_ = NULL;
	const gchar* _tmp31_ = NULL;
	gchar* _tmp32_ = NULL;
	GKeyFile* _tmp33_ = NULL;
	MainWindow* _tmp40_ = NULL;
	DialogDBusInterface* _tmp41_ = NULL;
	DialogDBusInterface* _tmp42_ = NULL;
	DialogDBusInterface* _tmp43_ = NULL;
	GError * _inner_error_ = NULL;
	self = (UnityGreeter*) g_type_create_instance (object_type);
	_tmp0_ = _unity_greeter_ref0 (self);
	_unity_greeter_unref0 (unity_greeter_singleton);
	unity_greeter_singleton = _tmp0_;
	_tmp1_ = test_mode_;
	self->test_mode = _tmp1_;
	g_debug ("unity-greeter.vala:57: Creating background surface");
	_tmp2_ = gdk_screen_get_default ();
	_tmp3_ = unity_greeter_create_root_surface (_tmp2_);
	_cairo_surface_destroy0 (self->priv->background_surface);
	self->priv->background_surface = _tmp3_;
	_tmp4_ = lightdm_greeter_new ();
	_g_object_unref0 (self->priv->greeter);
	self->priv->greeter = _tmp4_;
	_tmp5_ = self->priv->greeter;
	g_signal_connect (_tmp5_, "show-message", (GCallback) ___lambda57__lightdm_greeter_show_message, self);
	_tmp6_ = self->priv->greeter;
	g_signal_connect (_tmp6_, "show-prompt", (GCallback) ___lambda58__lightdm_greeter_show_prompt, self);
	_tmp7_ = self->priv->greeter;
	g_signal_connect (_tmp7_, "autologin-timer-expired", (GCallback) ___lambda59__lightdm_greeter_autologin_timer_expired, self);
	_tmp8_ = self->priv->greeter;
	g_signal_connect (_tmp8_, "authentication-complete", (GCallback) ___lambda60__lightdm_greeter_authentication_complete, self);
	connected = FALSE;
	{
		gboolean _tmp9_ = FALSE;
		LightDMGreeter* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp10_ = self->priv->greeter;
		_tmp11_ = lightdm_greeter_connect_to_daemon_sync (_tmp10_, &_inner_error_);
		_tmp9_ = _tmp11_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch31_g_error;
		}
		connected = _tmp9_;
	}
	goto __finally31;
	__catch31_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("unity-greeter.vala:72: Failed to connect to LightDM daemon");
		_g_error_free0 (e);
	}
	__finally31:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp13_ = connected;
	if (!_tmp13_) {
		gboolean _tmp14_ = FALSE;
		_tmp14_ = self->test_mode;
		_tmp12_ = !_tmp14_;
	} else {
		_tmp12_ = FALSE;
	}
	if (_tmp12_) {
		exit (EXIT_FAILURE);
	}
	_tmp15_ = self->test_mode;
	if (!_tmp15_) {
		SettingsDaemon* _tmp16_ = NULL;
		SettingsDaemon* _tmp17_ = NULL;
		_tmp16_ = settings_daemon_new ();
		_g_object_unref0 (self->priv->settings_daemon);
		self->priv->settings_daemon = _tmp16_;
		_tmp17_ = self->priv->settings_daemon;
		settings_daemon_start (_tmp17_);
	}
	_tmp18_ = g_get_user_cache_dir ();
	_tmp19_ = g_build_filename (_tmp18_, "unity-greeter", NULL);
	state_dir = _tmp19_;
	_tmp20_ = state_dir;
	g_mkdir_with_parents (_tmp20_, 0775);
	_tmp21_ = g_getenv ("XDG_SEAT");
	_tmp22_ = g_strdup (_tmp21_);
	xdg_seat = _tmp22_;
	_tmp25_ = xdg_seat;
	if (_tmp25_ != NULL) {
		const gchar* _tmp26_ = NULL;
		_tmp26_ = xdg_seat;
		_tmp24_ = g_strcmp0 (_tmp26_, "seat0") != 0;
	} else {
		_tmp24_ = FALSE;
	}
	if (_tmp24_) {
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		_tmp27_ = xdg_seat;
		_tmp28_ = g_strconcat (_tmp27_, "-state", NULL);
		_g_free0 (_tmp23_);
		_tmp23_ = _tmp28_;
	} else {
		gchar* _tmp29_ = NULL;
		_tmp29_ = g_strdup ("state");
		_g_free0 (_tmp23_);
		_tmp23_ = _tmp29_;
	}
	_tmp30_ = g_strdup (_tmp23_);
	state_file_name = _tmp30_;
	_tmp31_ = state_dir;
	_tmp32_ = g_build_filename (_tmp31_, state_file_name, NULL);
	_g_free0 (self->priv->state_file);
	self->priv->state_file = _tmp32_;
	_tmp33_ = g_key_file_new ();
	_g_key_file_unref0 (self->priv->state);
	self->priv->state = _tmp33_;
	{
		GKeyFile* _tmp34_ = NULL;
		const gchar* _tmp35_ = NULL;
		_tmp34_ = self->priv->state;
		_tmp35_ = self->priv->state_file;
		g_key_file_load_from_file (_tmp34_, _tmp35_, G_KEY_FILE_NONE, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch32_g_error;
		}
	}
	goto __finally32;
	__catch32_g_error:
	{
		GError* e = NULL;
		GError* _tmp36_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp36_ = e;
		if (!g_error_matches (_tmp36_, G_FILE_ERROR, G_FILE_ERROR_NOENT)) {
			const gchar* _tmp37_ = NULL;
			GError* _tmp38_ = NULL;
			const gchar* _tmp39_ = NULL;
			_tmp37_ = self->priv->state_file;
			_tmp38_ = e;
			_tmp39_ = _tmp38_->message;
			g_warning ("unity-greeter.vala:98: Failed to load state from %s: %s\n", _tmp37_, _tmp39_);
		}
		_g_error_free0 (e);
	}
	__finally32:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (state_file_name);
		_g_free0 (_tmp23_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp40_ = main_window_new ();
	g_object_ref_sink (_tmp40_);
	_g_object_unref0 (self->priv->main_window);
	self->priv->main_window = _tmp40_;
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "com.canonical.UnityGreeter", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)));
	_tmp41_ = dialog_dbus_interface_new ();
	_g_object_unref0 (self->priv->dbus_object);
	self->priv->dbus_object = _tmp41_;
	_tmp42_ = self->priv->dbus_object;
	g_signal_connect (_tmp42_, "open-dialog", (GCallback) ___lambda61__dialog_dbus_interface_open_dialog, self);
	_tmp43_ = self->priv->dbus_object;
	g_signal_connect (_tmp43_, "close-dialog", (GCallback) ___lambda62__dialog_dbus_interface_close_dialog, self);
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "com.canonical.Unity", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((___lambda63__gbus_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda63__gbus_acquired_callback, unity_greeter_ref (self), unity_greeter_unref)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((___lambda64__gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda64__gbus_name_lost_callback, unity_greeter_ref (self), unity_greeter_unref)));
	unity_greeter_start_fake_wm (self);
	gdk_threads_add_idle (_unity_greeter_ready_cb_gsource_func, self);
	_g_free0 (state_file_name);
	_g_free0 (_tmp23_);
	_g_free0 (xdg_seat);
	_g_free0 (state_dir);
	return self;
}


static UnityGreeter* unity_greeter_new (gboolean test_mode_) {
	return unity_greeter_construct (TYPE_UNITY_GREETER, test_mode_);
}


gchar* unity_greeter_get_state (UnityGreeter* self, const gchar* key) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp1_ = self->priv->state;
		_tmp2_ = key;
		_tmp3_ = g_key_file_get_value (_tmp1_, "greeter", _tmp2_, &_inner_error_);
		_tmp0_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch34_g_error;
		}
		_tmp4_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp4_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally34;
	__catch34_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = NULL;
		_g_error_free0 (e);
		return result;
	}
	__finally34:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void unity_greeter_set_state (UnityGreeter* self, const gchar* key, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* data = NULL;
	GKeyFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->priv->state;
	_tmp1_ = key;
	_tmp2_ = value;
	g_key_file_set_value (_tmp0_, "greeter", _tmp1_, _tmp2_);
	_tmp3_ = self->priv->state;
	_tmp4_ = g_key_file_to_data (_tmp3_, NULL, NULL);
	data = _tmp4_;
	{
		const gchar* _tmp5_ = NULL;
		_tmp5_ = self->priv->state_file;
		g_file_set_contents (_tmp5_, data, (gssize) -1, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch35_g_error;
		}
	}
	goto __finally35;
	__catch35_g_error:
	{
		GError* e = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_debug ("unity-greeter.vala:163: Failed to write state: %s", _tmp7_);
		_g_error_free0 (e);
	}
	__finally35:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (data);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (data);
}


void unity_greeter_push_list (UnityGreeter* self, GreeterList* widget) {
	MainWindow* _tmp0_ = NULL;
	GreeterList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = self->priv->main_window;
	_tmp1_ = widget;
	main_window_push_list (_tmp0_, _tmp1_);
}


void unity_greeter_pop_list (UnityGreeter* self) {
	MainWindow* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->main_window;
	main_window_pop_list (_tmp0_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void unity_greeter_add_style_class (GtkWidget* widget) {
	GtkStyleContext* ctx = NULL;
	GtkWidget* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStyleContext* _tmp2_ = NULL;
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	_tmp1_ = gtk_widget_get_style_context (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	ctx = _tmp2_;
	gtk_style_context_add_class (ctx, "lightdm");
	_g_object_unref0 (ctx);
}


gboolean unity_greeter_start_session (UnityGreeter* self, const gchar* session, Background* bg) {
	gboolean result = FALSE;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkScreen* _tmp1_ = NULL;
	gint scale = 0;
	GdkScreen* _tmp2_ = NULL;
	GdkScreen* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	cairo_surface_t* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	cairo_t* c = NULL;
	cairo_surface_t* _tmp9_ = NULL;
	cairo_t* _tmp10_ = NULL;
	Background* _tmp11_ = NULL;
	cairo_t* _tmp12_ = NULL;
	GdkScreen* _tmp13_ = NULL;
	cairo_surface_t* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	const gchar* _tmp16_ = NULL;
	gboolean _tmp17_ = FALSE;
	gboolean _result_ = FALSE;
	gboolean _tmp31_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bg != NULL, FALSE);
	_tmp0_ = gdk_screen_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	screen = _tmp1_;
	_tmp2_ = screen;
	_tmp3_ = screen;
	_tmp4_ = gdk_screen_get_number (_tmp3_);
	_tmp5_ = gdk_screen_get_monitor_scale_factor (_tmp2_, _tmp4_);
	scale = _tmp5_;
	_tmp6_ = self->priv->background_surface;
	_tmp7_ = scale;
	_tmp8_ = scale;
	cairo_surface_set_device_scale (_tmp6_, (gdouble) _tmp7_, (gdouble) _tmp8_);
	_tmp9_ = self->priv->background_surface;
	_tmp10_ = cairo_create (_tmp9_);
	c = _tmp10_;
	_tmp11_ = bg;
	_tmp12_ = c;
	background_draw_full (_tmp11_, _tmp12_, BACKGROUND_DRAW_FLAGS_NONE);
	_cairo_destroy0 (c);
	c = NULL;
	_tmp13_ = screen;
	_tmp14_ = self->priv->background_surface;
	unity_greeter_refresh_background (_tmp13_, _tmp14_);
	_tmp15_ = self->test_mode;
	if (_tmp15_) {
		g_debug ("unity-greeter.vala:199: Successfully logged in! Quitting...");
		gtk_main_quit ();
		result = TRUE;
		_cairo_destroy0 (c);
		_g_object_unref0 (screen);
		return result;
	}
	_tmp16_ = session;
	_tmp17_ = unity_greeter_session_is_valid (self, _tmp16_);
	if (!_tmp17_) {
		const gchar* _tmp18_ = NULL;
		LightDMGreeter* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		LightDMGreeter* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		_tmp18_ = session;
		_tmp19_ = self->priv->greeter;
		_tmp20_ = lightdm_greeter_get_default_session_hint (_tmp19_);
		_tmp21_ = _tmp20_;
		g_debug ("unity-greeter.vala:206: Session %s is not available, using system defa" \
"ult %s instead", _tmp18_, _tmp21_);
		_tmp22_ = self->priv->greeter;
		_tmp23_ = lightdm_greeter_get_default_session_hint (_tmp22_);
		_tmp24_ = _tmp23_;
		session = _tmp24_;
	}
	_result_ = FALSE;
	{
		gboolean _tmp25_ = FALSE;
		LightDMGreeter* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gboolean _tmp28_ = FALSE;
		_tmp26_ = self->priv->greeter;
		_tmp27_ = session;
		_tmp28_ = lightdm_greeter_start_session_sync (_tmp26_, _tmp27_, &_inner_error_);
		_tmp25_ = _tmp28_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch36_g_error;
		}
		_result_ = _tmp25_;
	}
	goto __finally36;
	__catch36_g_error:
	{
		GError* e = NULL;
		GError* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp29_ = e;
		_tmp30_ = _tmp29_->message;
		g_warning ("unity-greeter.vala:217: Failed to start session: %s", _tmp30_);
		_g_error_free0 (e);
	}
	__finally36:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_cairo_destroy0 (c);
		_g_object_unref0 (screen);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp31_ = _result_;
	if (_tmp31_) {
		g_signal_emit_by_name (self, "starting-session");
	}
	result = _result_;
	_cairo_destroy0 (c);
	_g_object_unref0 (screen);
	return result;
}


static gboolean unity_greeter_session_is_valid (UnityGreeter* self, const gchar* session) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = session;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = lightdm_get_sessions ();
	{
		GList* s_collection = NULL;
		GList* s_it = NULL;
		s_collection = _tmp1_;
		for (s_it = s_collection; s_it != NULL; s_it = s_it->next) {
			LightDMSession* _tmp2_ = NULL;
			LightDMSession* s = NULL;
			_tmp2_ = _g_object_ref0 ((LightDMSession*) s_it->data);
			s = _tmp2_;
			{
				LightDMSession* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				_tmp3_ = s;
				_tmp4_ = lightdm_session_get_key (_tmp3_);
				_tmp5_ = _tmp4_;
				_tmp6_ = session;
				if (g_strcmp0 (_tmp5_, _tmp6_) == 0) {
					result = TRUE;
					_g_object_unref0 (s);
					return result;
				}
				_g_object_unref0 (s);
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean unity_greeter_ready_cb (UnityGreeter* self) {
	gboolean result = FALSE;
	ca_context* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_debug ("unity-greeter.vala:240: starting system-ready sound");
	ca_context_create (&_tmp0_);
	_ca_context_destroy0 (self->priv->canberra_context);
	self->priv->canberra_context = _tmp0_;
	_tmp1_ = ug_settings_get_boolean (UG_SETTINGS_KEY_PLAY_READY_SOUND);
	if (_tmp1_) {
		ca_context* _tmp2_ = NULL;
		_tmp2_ = self->priv->canberra_context;
		ca_context_play (_tmp2_, (guint32) 0, CA_PROP_CANBERRA_XDG_THEME_NAME, "ubuntu", CA_PROP_EVENT_ID, "system-ready", NULL);
	}
	result = FALSE;
	return result;
}


void unity_greeter_show (UnityGreeter* self) {
	MainWindow* _tmp0_ = NULL;
	MainWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	MainWindow* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_debug ("unity-greeter.vala:257: Showing main window");
	_tmp0_ = self->priv->main_window;
	gtk_widget_show ((GtkWidget*) _tmp0_);
	_tmp1_ = self->priv->main_window;
	_tmp2_ = gtk_widget_get_window ((GtkWidget*) _tmp1_);
	gdk_window_focus (_tmp2_, (guint32) GDK_CURRENT_TIME);
	_tmp3_ = self->priv->main_window;
	main_window_set_keyboard_state (_tmp3_);
}


gboolean unity_greeter_is_authenticated (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_is_authenticated (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


void unity_greeter_authenticate (UnityGreeter* self, const gchar* userid) {
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = userid;
	lightdm_greeter_authenticate (_tmp0_, _tmp1_);
}


void unity_greeter_authenticate_as_guest (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_authenticate_as_guest (_tmp0_);
}


void unity_greeter_authenticate_remote (UnityGreeter* self, const gchar* session, const gchar* userid) {
	UnityGreeter* _tmp0_ = NULL;
	LightDMGreeter* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = unity_greeter_singleton;
	_tmp1_ = _tmp0_->priv->greeter;
	_tmp2_ = session;
	_tmp3_ = userid;
	lightdm_greeter_authenticate_remote (_tmp1_, _tmp2_, _tmp3_);
}


void unity_greeter_cancel_authentication (UnityGreeter* self) {
	LightDMGreeter* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->greeter;
	lightdm_greeter_cancel_authentication (_tmp0_);
}


void unity_greeter_respond (UnityGreeter* self, const gchar* response) {
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (response != NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = response;
	lightdm_greeter_respond (_tmp0_, _tmp1_);
}


gchar* unity_greeter_authentication_user (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_authentication_user (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gchar* unity_greeter_default_session_hint (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_default_session_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gchar* unity_greeter_select_user_hint (UnityGreeter* self) {
	gchar* result = NULL;
	LightDMGreeter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_select_user_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


gboolean unity_greeter_show_manual_login_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_show_manual_login_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_show_remote_login_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_show_remote_login_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_hide_users_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_hide_users_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


gboolean unity_greeter_has_guest_account_hint (UnityGreeter* self) {
	gboolean result = FALSE;
	LightDMGreeter* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->greeter;
	_tmp1_ = lightdm_greeter_get_has_guest_account_hint (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static GdkFilterReturn unity_greeter_focus_upon_map (UnityGreeter* self, GdkXEvent* gxevent, GdkEvent* event) {
	GdkFilterReturn result = 0;
	XEvent* xevent = NULL;
	GdkXEvent* _tmp0_ = NULL;
	XEvent* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (gxevent != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	_tmp0_ = gxevent;
	xevent = (XEvent*) _tmp0_;
	_tmp1_ = xevent;
	_tmp2_ = (*_tmp1_).type;
	if (_tmp2_ == ((gint) MapNotify)) {
		GdkX11Display* display = NULL;
		XEvent* _tmp3_ = NULL;
		XMapEvent _tmp4_ = {0};
		Display* _tmp5_ = NULL;
		GdkX11Display* _tmp6_ = NULL;
		GdkX11Display* _tmp7_ = NULL;
		Window xwin = 0;
		XEvent* _tmp8_ = NULL;
		XMapEvent _tmp9_ = {0};
		Window _tmp10_ = 0;
		GdkX11Window* win = NULL;
		GdkX11Display* _tmp11_ = NULL;
		Window _tmp12_ = 0;
		GdkX11Window* _tmp13_ = NULL;
		gboolean _tmp14_ = FALSE;
		GdkX11Window* _tmp15_ = NULL;
		_tmp3_ = xevent;
		_tmp4_ = (*_tmp3_).xmap;
		_tmp5_ = _tmp4_.display;
		_tmp6_ = gdk_x11_lookup_xdisplay (_tmp5_);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		display = _tmp7_;
		_tmp8_ = xevent;
		_tmp9_ = (*_tmp8_).xmap;
		_tmp10_ = _tmp9_.window;
		xwin = _tmp10_;
		_tmp11_ = display;
		_tmp12_ = xwin;
		_tmp13_ = (GdkX11Window*) gdk_x11_window_foreign_new_for_display (_tmp11_, _tmp12_);
		win = _tmp13_;
		_tmp15_ = win;
		if (_tmp15_ != NULL) {
			XEvent* _tmp16_ = NULL;
			XMapEvent _tmp17_ = {0};
			gboolean _tmp18_ = FALSE;
			_tmp16_ = xevent;
			_tmp17_ = (*_tmp16_).xmap;
			_tmp18_ = _tmp17_.override_redirect;
			_tmp14_ = !_tmp18_;
		} else {
			_tmp14_ = FALSE;
		}
		if (_tmp14_) {
			Window keyboard_xid = 0;
			MainWindow* _tmp19_ = NULL;
			MenuBar* _tmp20_ = NULL;
			GtkWindow* _tmp21_ = NULL;
			GtkWindow* _tmp22_ = NULL;
			gboolean _tmp29_ = FALSE;
			Window _tmp30_ = 0;
			Window _tmp31_ = 0;
			keyboard_xid = (Window) 0;
			_tmp19_ = self->priv->main_window;
			_tmp20_ = _tmp19_->menubar;
			_tmp21_ = menu_bar_get_keyboard_window (_tmp20_);
			_tmp22_ = _tmp21_;
			if (_tmp22_ != NULL) {
				MainWindow* _tmp23_ = NULL;
				MenuBar* _tmp24_ = NULL;
				GtkWindow* _tmp25_ = NULL;
				GtkWindow* _tmp26_ = NULL;
				GdkWindow* _tmp27_ = NULL;
				Window _tmp28_ = 0;
				_tmp23_ = self->priv->main_window;
				_tmp24_ = _tmp23_->menubar;
				_tmp25_ = menu_bar_get_keyboard_window (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = gtk_widget_get_window ((GtkWidget*) _tmp26_);
				_tmp28_ = gdk_x11_window_get_xid (G_TYPE_CHECK_INSTANCE_TYPE (_tmp27_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp27_) : NULL);
				keyboard_xid = _tmp28_;
			}
			_tmp30_ = xwin;
			_tmp31_ = keyboard_xid;
			if (_tmp30_ != _tmp31_) {
				GdkX11Window* _tmp32_ = NULL;
				GdkWindowTypeHint _tmp33_ = 0;
				_tmp32_ = win;
				_tmp33_ = gdk_window_get_type_hint ((GdkWindow*) _tmp32_);
				_tmp29_ = _tmp33_ != GDK_WINDOW_TYPE_HINT_NOTIFICATION;
			} else {
				_tmp29_ = FALSE;
			}
			if (_tmp29_) {
				GdkX11Window* _tmp34_ = NULL;
				MainWindow* _tmp35_ = NULL;
				MenuBar* _tmp36_ = NULL;
				GtkWindow* _tmp37_ = NULL;
				GtkWindow* _tmp38_ = NULL;
				_tmp34_ = win;
				gdk_window_focus ((GdkWindow*) _tmp34_, (guint32) GDK_CURRENT_TIME);
				_tmp35_ = self->priv->main_window;
				_tmp36_ = _tmp35_->menubar;
				_tmp37_ = menu_bar_get_keyboard_window (_tmp36_);
				_tmp38_ = _tmp37_;
				if (_tmp38_ != NULL) {
					MainWindow* _tmp39_ = NULL;
					MenuBar* _tmp40_ = NULL;
					GtkWindow* _tmp41_ = NULL;
					GtkWindow* _tmp42_ = NULL;
					GdkWindow* _tmp43_ = NULL;
					_tmp39_ = self->priv->main_window;
					_tmp40_ = _tmp39_->menubar;
					_tmp41_ = menu_bar_get_keyboard_window (_tmp40_);
					_tmp42_ = _tmp41_;
					_tmp43_ = gtk_widget_get_window ((GtkWidget*) _tmp42_);
					gdk_window_raise (_tmp43_);
				}
			}
		}
		_g_object_unref0 (win);
		_g_object_unref0 (display);
	} else {
		XEvent* _tmp44_ = NULL;
		gint _tmp45_ = 0;
		_tmp44_ = xevent;
		_tmp45_ = (*_tmp44_).type;
		if (_tmp45_ == ((gint) UnmapNotify)) {
			Window xwin = 0;
			gint revert_to = 0;
			XEvent* _tmp46_ = NULL;
			XUnmapEvent _tmp47_ = {0};
			Display* _tmp48_ = NULL;
			Window _tmp49_ = 0;
			gint _tmp50_ = 0;
			gint _tmp51_ = 0;
			_tmp46_ = xevent;
			_tmp47_ = (*_tmp46_).xunmap;
			_tmp48_ = _tmp47_.display;
			XGetInputFocus (_tmp48_, &_tmp49_, &_tmp50_);
			xwin = _tmp49_;
			revert_to = _tmp50_;
			_tmp51_ = revert_to;
			if (_tmp51_ == ((gint) RevertToNone)) {
				MainWindow* _tmp52_ = NULL;
				GdkWindow* _tmp53_ = NULL;
				MainWindow* _tmp54_ = NULL;
				MenuBar* _tmp55_ = NULL;
				GtkWindow* _tmp56_ = NULL;
				GtkWindow* _tmp57_ = NULL;
				_tmp52_ = self->priv->main_window;
				_tmp53_ = gtk_widget_get_window ((GtkWidget*) _tmp52_);
				gdk_window_focus (_tmp53_, (guint32) GDK_CURRENT_TIME);
				_tmp54_ = self->priv->main_window;
				_tmp55_ = _tmp54_->menubar;
				_tmp56_ = menu_bar_get_keyboard_window (_tmp55_);
				_tmp57_ = _tmp56_;
				if (_tmp57_ != NULL) {
					MainWindow* _tmp58_ = NULL;
					MenuBar* _tmp59_ = NULL;
					GtkWindow* _tmp60_ = NULL;
					GtkWindow* _tmp61_ = NULL;
					GdkWindow* _tmp62_ = NULL;
					_tmp58_ = self->priv->main_window;
					_tmp59_ = _tmp58_->menubar;
					_tmp60_ = menu_bar_get_keyboard_window (_tmp59_);
					_tmp61_ = _tmp60_;
					_tmp62_ = gtk_widget_get_window ((GtkWidget*) _tmp61_);
					gdk_window_raise (_tmp62_);
				}
			}
		}
	}
	result = GDK_FILTER_CONTINUE;
	return result;
}


static GdkFilterReturn _unity_greeter_focus_upon_map_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = unity_greeter_focus_upon_map ((UnityGreeter*) self, xevent, event);
	return result;
}


static void unity_greeter_start_fake_wm (UnityGreeter* self) {
	GdkWindow* root = NULL;
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkEventMask _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gdk_get_default_root_window ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	root = _tmp1_;
	_tmp2_ = gdk_window_get_events (root);
	gdk_window_set_events (root, _tmp2_ | GDK_SUBSTRUCTURE_MASK);
	gdk_window_add_filter (root, _unity_greeter_focus_upon_map_gdk_filter_func, self);
	_g_object_unref0 (root);
}


static cairo_surface_t* unity_greeter_create_root_surface (GdkScreen* screen) {
	cairo_surface_t* result = NULL;
	GdkVisual* visual = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkVisual* _tmp1_ = NULL;
	GdkVisual* _tmp2_ = NULL;
	Display* display = NULL;
	GdkScreen* _tmp3_ = NULL;
	GdkDisplay* _tmp4_ = NULL;
	Display* _tmp5_ = NULL;
	Screen* xscreen = NULL;
	GdkScreen* _tmp6_ = NULL;
	Screen* _tmp7_ = NULL;
	gint pixmap = 0;
	GdkScreen* _tmp8_ = NULL;
	GdkWindow* _tmp9_ = NULL;
	Window _tmp10_ = 0;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	cairo_surface_t* surface = NULL;
	Visual* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	cairo_surface_t* _tmp18_ = NULL;
	g_return_val_if_fail (screen != NULL, NULL);
	_tmp0_ = screen;
	_tmp1_ = gdk_screen_get_system_visual (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	visual = _tmp2_;
	_tmp3_ = screen;
	_tmp4_ = gdk_screen_get_display (_tmp3_);
	_tmp5_ = gdk_x11_display_get_xdisplay (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp4_) : NULL);
	display = _tmp5_;
	_tmp6_ = screen;
	_tmp7_ = gdk_x11_screen_get_xscreen (G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, gdk_x11_screen_get_type ()) ? ((GdkX11Screen*) _tmp6_) : NULL);
	xscreen = _tmp7_;
	_tmp8_ = screen;
	_tmp9_ = gdk_screen_get_root_window (_tmp8_);
	_tmp10_ = gdk_x11_window_get_xid (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp9_) : NULL);
	_tmp11_ = WidthOfScreen (xscreen);
	_tmp12_ = HeightOfScreen (xscreen);
	_tmp13_ = gdk_visual_get_depth (visual);
	_tmp14_ = XCreatePixmap (display, (Drawable) _tmp10_, (guint) _tmp11_, (guint) _tmp12_, (guint) _tmp13_);
	pixmap = _tmp14_;
	_tmp15_ = gdk_x11_visual_get_xvisual (G_TYPE_CHECK_INSTANCE_TYPE (visual, gdk_x11_visual_get_type ()) ? ((GdkX11Visual*) visual) : NULL);
	_tmp16_ = WidthOfScreen (xscreen);
	_tmp17_ = HeightOfScreen (xscreen);
	_tmp18_ = cairo_xlib_surface_create (display, pixmap, _tmp15_, _tmp16_, _tmp17_);
	surface = _tmp18_;
	result = surface;
	_g_object_unref0 (visual);
	return result;
}


static void unity_greeter_refresh_background (GdkScreen* screen, cairo_surface_t* surface) {
	Display* display = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkDisplay* _tmp1_ = NULL;
	Display* _tmp2_ = NULL;
	cairo_surface_t* _tmp3_ = NULL;
	GdkScreen* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	Window _tmp6_ = 0;
	cairo_surface_t* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	GdkScreen* _tmp9_ = NULL;
	GdkWindow* _tmp10_ = NULL;
	Window _tmp11_ = 0;
	g_return_if_fail (screen != NULL);
	g_return_if_fail (surface != NULL);
	gdk_flush ();
	_tmp0_ = screen;
	_tmp1_ = gdk_screen_get_display (_tmp0_);
	_tmp2_ = gdk_x11_display_get_xdisplay (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp1_) : NULL);
	display = _tmp2_;
	_tmp3_ = surface;
	cairo_surface_flush (_tmp3_);
	_tmp4_ = screen;
	_tmp5_ = gdk_screen_get_root_window (_tmp4_);
	_tmp6_ = gdk_x11_window_get_xid (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp5_) : NULL);
	_tmp7_ = surface;
	_tmp8_ = cairo_xlib_surface_get_drawable (_tmp7_);
	XSetWindowBackgroundPixmap (display, _tmp6_, _tmp8_);
	_tmp9_ = screen;
	_tmp10_ = gdk_screen_get_root_window (_tmp9_);
	_tmp11_ = gdk_x11_window_get_xid (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp10_) : NULL);
	XClearWindow (display, _tmp11_);
}


static void unity_greeter_log_cb (const gchar* log_domain, GLogLevelFlags log_level, const gchar* message) {
	gchar* prefix = NULL;
	GLogLevelFlags _tmp0_ = 0;
	FILE* _tmp8_ = NULL;
	GTimer* _tmp9_ = NULL;
	gdouble _tmp10_ = 0.0;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	g_return_if_fail (message != NULL);
	_tmp0_ = log_level;
	switch (_tmp0_ & G_LOG_LEVEL_MASK) {
		case G_LOG_LEVEL_ERROR:
		{
			gchar* _tmp1_ = NULL;
			_tmp1_ = g_strdup ("ERROR:");
			_g_free0 (prefix);
			prefix = _tmp1_;
			break;
		}
		case G_LOG_LEVEL_CRITICAL:
		{
			gchar* _tmp2_ = NULL;
			_tmp2_ = g_strdup ("CRITICAL:");
			_g_free0 (prefix);
			prefix = _tmp2_;
			break;
		}
		case G_LOG_LEVEL_WARNING:
		{
			gchar* _tmp3_ = NULL;
			_tmp3_ = g_strdup ("WARNING:");
			_g_free0 (prefix);
			prefix = _tmp3_;
			break;
		}
		case G_LOG_LEVEL_MESSAGE:
		{
			gchar* _tmp4_ = NULL;
			_tmp4_ = g_strdup ("MESSAGE:");
			_g_free0 (prefix);
			prefix = _tmp4_;
			break;
		}
		case G_LOG_LEVEL_INFO:
		{
			gchar* _tmp5_ = NULL;
			_tmp5_ = g_strdup ("INFO:");
			_g_free0 (prefix);
			prefix = _tmp5_;
			break;
		}
		case G_LOG_LEVEL_DEBUG:
		{
			gchar* _tmp6_ = NULL;
			_tmp6_ = g_strdup ("DEBUG:");
			_g_free0 (prefix);
			prefix = _tmp6_;
			break;
		}
		default:
		{
			gchar* _tmp7_ = NULL;
			_tmp7_ = g_strdup ("LOG:");
			_g_free0 (prefix);
			prefix = _tmp7_;
			break;
		}
	}
	_tmp8_ = stderr;
	_tmp9_ = unity_greeter_log_timer;
	_tmp10_ = g_timer_elapsed (_tmp9_, NULL);
	_tmp11_ = prefix;
	_tmp12_ = message;
	fprintf (_tmp8_, "[%+.2fs] %s %s\n", _tmp10_, _tmp11_, _tmp12_);
	_g_free0 (prefix);
}


static void _unity_greeter_log_cb_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	unity_greeter_log_cb (log_domain, log_levels, message);
}


static gboolean __lambda65_ (void) {
	gboolean result = FALSE;
	g_debug ("unity-greeter.vala:611: Got a SIGTERM");
	gtk_main_quit ();
	result = TRUE;
	return result;
}


static gboolean ___lambda65__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda65_ ();
	return result;
}


gint unity_greeter_main (gchar** args, int args_length1) {
	gint result = 0;
	GPid atspi_pid = 0;
	GPid upstart_pid = 0;
	GTimer* _tmp6_ = NULL;
	uid_t _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	GdkWindow* _tmp9_ = NULL;
	GdkDisplay* _tmp10_ = NULL;
	GdkCursor* _tmp11_ = NULL;
	GdkCursor* _tmp12_ = NULL;
	gboolean do_show_version = FALSE;
	gboolean do_test_mode = FALSE;
	GOptionEntry versionOption = {0};
	GOptionEntry _tmp13_ = {0};
	GOptionEntry testOption = {0};
	GOptionEntry _tmp14_ = {0};
	GOptionEntry nullOption = {0};
	GOptionEntry _tmp15_ = {0};
	GOptionEntry* options = NULL;
	GOptionEntry _tmp16_ = {0};
	GOptionEntry _tmp17_ = {0};
	GOptionEntry _tmp18_ = {0};
	GOptionEntry* _tmp19_ = NULL;
	gint options_length1 = 0;
	gint _options_size_ = 0;
	GOptionContext* c = NULL;
	const gchar* _tmp20_ = NULL;
	GOptionContext* _tmp21_ = NULL;
	GOptionContext* _tmp22_ = NULL;
	GOptionEntry* _tmp23_ = NULL;
	gint _tmp23__length1 = 0;
	GOptionContext* _tmp24_ = NULL;
	GOptionGroup* _tmp25_ = NULL;
	gboolean _tmp35_ = FALSE;
	gboolean _tmp37_ = FALSE;
	GtkSettings* settings = NULL;
	GtkSettings* _tmp38_ = NULL;
	GtkSettings* _tmp39_ = NULL;
	gchar* value = NULL;
	gchar* _tmp40_ = NULL;
	const gchar* _tmp41_ = NULL;
	gchar* _tmp44_ = NULL;
	const gchar* _tmp45_ = NULL;
	gchar* _tmp48_ = NULL;
	const gchar* _tmp49_ = NULL;
	gdouble double_value = 0.0;
	gdouble _tmp52_ = 0.0;
	gdouble _tmp53_ = 0.0;
	gboolean boolean_value = FALSE;
	gboolean _tmp56_ = FALSE;
	GtkSettings* _tmp57_ = NULL;
	gboolean _tmp58_ = FALSE;
	gchar* _tmp59_ = NULL;
	const gchar* _tmp60_ = NULL;
	gchar* _tmp63_ = NULL;
	const gchar* _tmp64_ = NULL;
	UnityGreeter* greeter = NULL;
	gboolean _tmp67_ = FALSE;
	UnityGreeter* _tmp68_ = NULL;
	UnityGreeter* _tmp69_ = NULL;
	gboolean _tmp70_ = FALSE;
	GPid _tmp79_ = 0;
	GPid _tmp89_ = 0;
	GError * _inner_error_ = NULL;
	mlockall (MCL_CURRENT | MCL_FUTURE);
	g_unsetenv ("UBUNTU_MENUPROXY");
	setlocale (LC_ALL, "");
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	g_setenv ("GTK_MODULES", "atk-bridge", FALSE);
	atspi_pid = (GPid) 0;
	upstart_pid = (GPid) 0;
	{
		gchar** argv = NULL;
		gint argv_length1 = 0;
		gint _argv_size_ = 0;
		gchar** _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gchar** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		GPid _tmp3_ = 0;
		g_shell_parse_argv ("/usr/lib/at-spi2-core/at-spi-bus-launcher --launch-immediately", &_tmp1_, &_tmp0_, &_inner_error_);
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		argv = _tmp0_;
		argv_length1 = _tmp1_;
		_argv_size_ = argv_length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			goto __catch37_g_error;
		}
		_tmp2_ = argv;
		_tmp2__length1 = argv_length1;
		g_spawn_async (NULL, _tmp2_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp3_, &_inner_error_);
		atspi_pid = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			goto __catch37_g_error;
		}
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally37;
	__catch37_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("unity-greeter.vala:493: Error starting the at-spi registry: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally37:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	gtk_init (&args_length1, &args);
	ido_init ();
	_tmp6_ = g_timer_new ();
	_g_timer_destroy0 (unity_greeter_log_timer);
	unity_greeter_log_timer = _tmp6_;
	g_log_set_default_handler (_unity_greeter_log_cb_glog_func, NULL);
	_tmp7_ = getuid ();
	_tmp8_ = g_getenv ("LANG");
	g_debug ("unity-greeter.vala:502: Starting unity-greeter %s UID=%d LANG=%s", VERSION, (gint) _tmp7_, _tmp8_);
	g_debug ("unity-greeter.vala:505: Setting cursor");
	_tmp9_ = gdk_get_default_root_window ();
	_tmp10_ = gdk_display_get_default ();
	_tmp11_ = gdk_cursor_new_for_display (_tmp10_, GDK_LEFT_PTR);
	_tmp12_ = _tmp11_;
	gdk_window_set_cursor (_tmp9_, _tmp12_);
	_g_object_unref0 (_tmp12_);
	do_show_version = FALSE;
	do_test_mode = FALSE;
	_tmp13_.long_name = "version";
	_tmp13_.short_name = 'v';
	_tmp13_.flags = 0;
	_tmp13_.arg = G_OPTION_ARG_NONE;
	_tmp13_.arg_data = &do_show_version;
	_tmp13_.description = "Show release version";
	_tmp13_.arg_description = NULL;
	versionOption = _tmp13_;
	_tmp14_.long_name = "test-mode";
	_tmp14_.short_name = (gchar) 0;
	_tmp14_.flags = 0;
	_tmp14_.arg = G_OPTION_ARG_NONE;
	_tmp14_.arg_data = &do_test_mode;
	_tmp14_.description = "Run in test mode";
	_tmp14_.arg_description = NULL;
	testOption = _tmp14_;
	_tmp15_.long_name = NULL;
	nullOption = _tmp15_;
	_tmp16_ = versionOption;
	_tmp17_ = testOption;
	_tmp18_ = nullOption;
	_tmp19_ = g_new0 (GOptionEntry, 3);
	_tmp19_[0] = _tmp16_;
	_tmp19_[1] = _tmp17_;
	_tmp19_[2] = _tmp18_;
	options = _tmp19_;
	options_length1 = 3;
	_options_size_ = options_length1;
	g_debug ("unity-greeter.vala:519: Loading command line options");
	_tmp20_ = _ ("- Unity Greeter");
	_tmp21_ = g_option_context_new (_tmp20_);
	c = _tmp21_;
	_tmp22_ = c;
	_tmp23_ = options;
	_tmp23__length1 = options_length1;
	g_option_context_add_main_entries (_tmp22_, _tmp23_, GETTEXT_PACKAGE);
	_tmp24_ = c;
	_tmp25_ = gtk_get_option_group (TRUE);
	g_option_context_add_group (_tmp24_, _tmp25_);
	{
		GOptionContext* _tmp26_ = NULL;
		_tmp26_ = c;
		g_option_context_parse (_tmp26_, &args_length1, &args, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch38_g_error;
		}
	}
	goto __finally38;
	__catch38_g_error:
	{
		GError* e = NULL;
		FILE* _tmp27_ = NULL;
		GError* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		FILE* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		gchar** _tmp32_ = NULL;
		gint _tmp32__length1 = 0;
		const gchar* _tmp33_ = NULL;
		FILE* _tmp34_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = stderr;
		_tmp28_ = e;
		_tmp29_ = _tmp28_->message;
		fprintf (_tmp27_, "%s\n", _tmp29_);
		_tmp30_ = stderr;
		_tmp31_ = _ ("Run '%s --help' to see a full list of available command line options.");
		_tmp32_ = args;
		_tmp32__length1 = args_length1;
		_tmp33_ = _tmp32_[0];
		fprintf (_tmp30_, _tmp31_, _tmp33_);
		_tmp34_ = stderr;
		fprintf (_tmp34_, "\n");
		result = EXIT_FAILURE;
		_g_error_free0 (e);
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		return result;
	}
	__finally38:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp35_ = do_show_version;
	if (_tmp35_) {
		FILE* _tmp36_ = NULL;
		_tmp36_ = stderr;
		fprintf (_tmp36_, "unity-greeter %s\n", VERSION);
		result = EXIT_SUCCESS;
		_g_option_context_free0 (c);
		options = (g_free (options), NULL);
		return result;
	}
	_tmp37_ = do_test_mode;
	if (_tmp37_) {
		g_debug ("unity-greeter.vala:544: Running in test mode");
	}
	g_debug ("unity-greeter.vala:547: Setting GTK+ settings");
	_tmp38_ = gtk_settings_get_default ();
	_tmp39_ = _g_object_ref0 (_tmp38_);
	settings = _tmp39_;
	_tmp40_ = ug_settings_get_string (UG_SETTINGS_KEY_THEME_NAME);
	value = _tmp40_;
	_tmp41_ = value;
	if (g_strcmp0 (_tmp41_, "") != 0) {
		GtkSettings* _tmp42_ = NULL;
		const gchar* _tmp43_ = NULL;
		_tmp42_ = settings;
		_tmp43_ = value;
		g_object_set ((GObject*) _tmp42_, "gtk-theme-name", _tmp43_, NULL, NULL);
	}
	_tmp44_ = ug_settings_get_string (UG_SETTINGS_KEY_ICON_THEME_NAME);
	_g_free0 (value);
	value = _tmp44_;
	_tmp45_ = value;
	if (g_strcmp0 (_tmp45_, "") != 0) {
		GtkSettings* _tmp46_ = NULL;
		const gchar* _tmp47_ = NULL;
		_tmp46_ = settings;
		_tmp47_ = value;
		g_object_set ((GObject*) _tmp46_, "gtk-icon-theme-name", _tmp47_, NULL, NULL);
	}
	_tmp48_ = ug_settings_get_string (UG_SETTINGS_KEY_FONT_NAME);
	_g_free0 (value);
	value = _tmp48_;
	_tmp49_ = value;
	if (g_strcmp0 (_tmp49_, "") != 0) {
		GtkSettings* _tmp50_ = NULL;
		const gchar* _tmp51_ = NULL;
		_tmp50_ = settings;
		_tmp51_ = value;
		g_object_set ((GObject*) _tmp50_, "gtk-font-name", _tmp51_, NULL, NULL);
	}
	_tmp52_ = ug_settings_get_double (UG_SETTINGS_KEY_XFT_DPI);
	double_value = _tmp52_;
	_tmp53_ = double_value;
	if (_tmp53_ != 0.0) {
		GtkSettings* _tmp54_ = NULL;
		gdouble _tmp55_ = 0.0;
		_tmp54_ = settings;
		_tmp55_ = double_value;
		g_object_set ((GObject*) _tmp54_, "gtk-xft-dpi", (gint) (1024 * _tmp55_), NULL, NULL);
	}
	_tmp56_ = ug_settings_get_boolean (UG_SETTINGS_KEY_XFT_ANTIALIAS);
	boolean_value = _tmp56_;
	_tmp57_ = settings;
	_tmp58_ = boolean_value;
	g_object_set ((GObject*) _tmp57_, "gtk-xft-antialias", _tmp58_, NULL, NULL);
	_tmp59_ = ug_settings_get_string (UG_SETTINGS_KEY_XFT_HINTSTYLE);
	_g_free0 (value);
	value = _tmp59_;
	_tmp60_ = value;
	if (g_strcmp0 (_tmp60_, "") != 0) {
		GtkSettings* _tmp61_ = NULL;
		const gchar* _tmp62_ = NULL;
		_tmp61_ = settings;
		_tmp62_ = value;
		g_object_set ((GObject*) _tmp61_, "gtk-xft-hintstyle", _tmp62_, NULL, NULL);
	}
	_tmp63_ = ug_settings_get_string (UG_SETTINGS_KEY_XFT_RGBA);
	_g_free0 (value);
	value = _tmp63_;
	_tmp64_ = value;
	if (g_strcmp0 (_tmp64_, "") != 0) {
		GtkSettings* _tmp65_ = NULL;
		const gchar* _tmp66_ = NULL;
		_tmp65_ = settings;
		_tmp66_ = value;
		g_object_set ((GObject*) _tmp65_, "gtk-xft-rgba", _tmp66_, NULL, NULL);
	}
	g_debug ("unity-greeter.vala:570: Creating Unity Greeter");
	_tmp67_ = do_test_mode;
	_tmp68_ = unity_greeter_new (_tmp67_);
	greeter = _tmp68_;
	g_debug ("unity-greeter.vala:573: Showing greeter");
	_tmp69_ = greeter;
	unity_greeter_show (_tmp69_);
	_tmp70_ = do_test_mode;
	if (!_tmp70_) {
		{
			gchar** argv = NULL;
			gint argv_length1 = 0;
			gint _argv_size_ = 0;
			gchar** _tmp71_ = NULL;
			gint _tmp72_ = 0;
			gchar** _tmp73_ = NULL;
			gint _tmp73__length1 = 0;
			GPid _tmp74_ = 0;
			g_shell_parse_argv ("upstart --user --startup-event indicator-services-start", &_tmp72_, &_tmp71_, &_inner_error_);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			argv = _tmp71_;
			argv_length1 = _tmp72_;
			_argv_size_ = argv_length1;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch39_g_error;
			}
			_tmp73_ = argv;
			_tmp73__length1 = argv_length1;
			g_spawn_async (NULL, _tmp73_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp74_, &_inner_error_);
			upstart_pid = _tmp74_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch39_g_error;
			}
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		}
		goto __finally39;
		__catch39_g_error:
		{
			GError* e = NULL;
			GError* _tmp75_ = NULL;
			const gchar* _tmp76_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp75_ = e;
			_tmp76_ = _tmp75_->message;
			g_warning ("unity-greeter.vala:593: Error starting Upstart for indicators: %s", _tmp76_);
			_g_error_free0 (e);
		}
		__finally39:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_unity_greeter_unref0 (greeter);
			_g_free0 (value);
			_g_object_unref0 (settings);
			_g_option_context_free0 (c);
			options = (g_free (options), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		g_setenv ("NM_APPLET_HIDE_POLICY_ITEMS", "1", TRUE);
		{
			g_spawn_command_line_async ("nm-applet", &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch40_g_error;
			}
		}
		goto __finally40;
		__catch40_g_error:
		{
			GError* e = NULL;
			GError* _tmp77_ = NULL;
			const gchar* _tmp78_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp77_ = e;
			_tmp78_ = _tmp77_->message;
			g_warning ("unity-greeter.vala:605: Error starting nm-applet: %s", _tmp78_);
			_g_error_free0 (e);
		}
		__finally40:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_unity_greeter_unref0 (greeter);
			_g_free0 (value);
			_g_object_unref0 (settings);
			_g_option_context_free0 (c);
			options = (g_free (options), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	}
	g_unix_signal_add_full (G_PRIORITY_DEFAULT, (gint) SIGTERM, ___lambda65__gsource_func, NULL, NULL);
	g_debug ("unity-greeter.vala:616: Starting main loop");
	gtk_main ();
	g_debug ("unity-greeter.vala:619: Cleaning up");
	_tmp79_ = upstart_pid;
	if (_tmp79_ != ((GPid) 0)) {
		GPid _tmp80_ = 0;
		gint status = 0;
		GPid _tmp81_ = 0;
		gint _tmp82_ = 0;
		gint _tmp83_ = 0;
		gboolean _tmp84_ = FALSE;
		_tmp80_ = upstart_pid;
		kill ((pid_t) _tmp80_, SIGTERM);
		_tmp81_ = upstart_pid;
		waitpid ((pid_t) _tmp81_, &_tmp82_, 0);
		status = _tmp82_;
		_tmp83_ = status;
		_tmp84_ = WIFEXITED (_tmp83_);
		if (_tmp84_) {
			gint _tmp85_ = 0;
			gint _tmp86_ = 0;
			_tmp85_ = status;
			_tmp86_ = WEXITSTATUS (_tmp85_);
			g_debug ("unity-greeter.vala:627: Upstart exited with return value %d", _tmp86_);
		} else {
			gint _tmp87_ = 0;
			int _tmp88_ = 0;
			_tmp87_ = status;
			_tmp88_ = WTERMSIG (_tmp87_);
			g_debug ("unity-greeter.vala:629: Upstart terminated with signal %d", (gint) _tmp88_);
		}
		upstart_pid = (GPid) 0;
	}
	_tmp89_ = atspi_pid;
	if (_tmp89_ != ((GPid) 0)) {
		GPid _tmp90_ = 0;
		gint status = 0;
		GPid _tmp91_ = 0;
		gint _tmp92_ = 0;
		gint _tmp93_ = 0;
		gboolean _tmp94_ = FALSE;
		_tmp90_ = atspi_pid;
		kill ((pid_t) _tmp90_, SIGKILL);
		_tmp91_ = atspi_pid;
		waitpid ((pid_t) _tmp91_, &_tmp92_, 0);
		status = _tmp92_;
		_tmp93_ = status;
		_tmp94_ = WIFEXITED (_tmp93_);
		if (_tmp94_) {
			gint _tmp95_ = 0;
			gint _tmp96_ = 0;
			_tmp95_ = status;
			_tmp96_ = WEXITSTATUS (_tmp95_);
			g_debug ("unity-greeter.vala:639: AT-SPI exited with return value %d", _tmp96_);
		} else {
			gint _tmp97_ = 0;
			int _tmp98_ = 0;
			_tmp97_ = status;
			_tmp98_ = WTERMSIG (_tmp97_);
			g_debug ("unity-greeter.vala:641: AT-SPI terminated with signal %d", (gint) _tmp98_);
		}
		atspi_pid = (GPid) 0;
	}
	g_debug ("unity-greeter.vala:645: Exiting");
	result = EXIT_SUCCESS;
	_unity_greeter_unref0 (greeter);
	_g_free0 (value);
	_g_object_unref0 (settings);
	_g_option_context_free0 (c);
	options = (g_free (options), NULL);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return unity_greeter_main (argv, argc);
}


static void g_cclosure_user_marshal_VOID__STRING_ENUM (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_ENUM) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_ENUM callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_ENUM) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_enum (param_values + 2), data2);
}


static void value_unity_greeter_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_unity_greeter_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		unity_greeter_unref (value->data[0].v_pointer);
	}
}


static void value_unity_greeter_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = unity_greeter_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_unity_greeter_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_unity_greeter_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UnityGreeter* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = unity_greeter_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_unity_greeter_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UnityGreeter** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = unity_greeter_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecUnityGreeter* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_UNITY_GREETER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_unity_greeter (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER), NULL);
	return value->data[0].v_pointer;
}


void value_set_unity_greeter (GValue* value, gpointer v_object) {
	UnityGreeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_UNITY_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		unity_greeter_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_greeter_unref (old);
	}
}


void value_take_unity_greeter (GValue* value, gpointer v_object) {
	UnityGreeter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_UNITY_GREETER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_UNITY_GREETER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		unity_greeter_unref (old);
	}
}


static void unity_greeter_class_init (UnityGreeterClass * klass) {
	unity_greeter_parent_class = g_type_class_peek_parent (klass);
	((UnityGreeterClass *) klass)->finalize = unity_greeter_finalize;
	g_type_class_add_private (klass, sizeof (UnityGreeterPrivate));
	g_signal_new ("show_message", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_ENUM, G_TYPE_NONE, 2, G_TYPE_STRING, lightdm_message_type_get_type ());
	g_signal_new ("show_prompt", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_ENUM, G_TYPE_NONE, 2, G_TYPE_STRING, lightdm_prompt_type_get_type ());
	g_signal_new ("authentication_complete", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("starting_session", TYPE_UNITY_GREETER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void unity_greeter_instance_init (UnityGreeter * self) {
	self->priv = UNITY_GREETER_GET_PRIVATE (self);
	self->test_mode = FALSE;
	self->ref_count = 1;
}


static void unity_greeter_finalize (UnityGreeter* obj) {
	UnityGreeter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_UNITY_GREETER, UnityGreeter);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->state_file);
	_g_key_file_unref0 (self->priv->state);
	_cairo_surface_destroy0 (self->priv->background_surface);
	_g_object_unref0 (self->priv->settings_daemon);
	_g_object_unref0 (self->priv->main_window);
	_g_object_unref0 (self->priv->greeter);
	_ca_context_destroy0 (self->priv->canberra_context);
	_g_object_unref0 (self->priv->dbus_object);
}


GType unity_greeter_get_type (void) {
	static volatile gsize unity_greeter_type_id__volatile = 0;
	if (g_once_init_enter (&unity_greeter_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_unity_greeter_init, value_unity_greeter_free_value, value_unity_greeter_copy_value, value_unity_greeter_peek_pointer, "p", value_unity_greeter_collect_value, "p", value_unity_greeter_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (UnityGreeterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) unity_greeter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UnityGreeter), 0, (GInstanceInitFunc) unity_greeter_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType unity_greeter_type_id;
		unity_greeter_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UnityGreeter", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&unity_greeter_type_id__volatile, unity_greeter_type_id);
	}
	return unity_greeter_type_id__volatile;
}


gpointer unity_greeter_ref (gpointer instance) {
	UnityGreeter* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void unity_greeter_unref (gpointer instance) {
	UnityGreeter* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		UNITY_GREETER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void dialog_dbus_interface_open (DialogDBusInterface* self, guint32 type, guint32 timestamp, guint32 seconds_to_stay_open, char** inhibitor_object_paths, int inhibitor_object_paths_length1) {
	guint32 _tmp0_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = type;
	g_signal_emit_by_name (self, "open-dialog", _tmp0_);
}


void dialog_dbus_interface_close (DialogDBusInterface* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "close-dialog");
}


DialogDBusInterface* dialog_dbus_interface_construct (GType object_type) {
	DialogDBusInterface * self = NULL;
	self = (DialogDBusInterface*) g_object_new (object_type, NULL);
	return self;
}


DialogDBusInterface* dialog_dbus_interface_new (void) {
	return dialog_dbus_interface_construct (TYPE_DIALOG_DBUS_INTERFACE);
}


static void dialog_dbus_interface_class_init (DialogDBusInterfaceClass * klass) {
	dialog_dbus_interface_parent_class = g_type_class_peek_parent (klass);
	g_signal_new ("open_dialog", TYPE_DIALOG_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__UINT, G_TYPE_NONE, 1, G_TYPE_UINT);
	g_signal_new ("close_dialog", TYPE_DIALOG_DBUS_INTERFACE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void dialog_dbus_interface_instance_init (DialogDBusInterface * self) {
}


GType dialog_dbus_interface_get_type (void) {
	static volatile gsize dialog_dbus_interface_type_id__volatile = 0;
	if (g_once_init_enter (&dialog_dbus_interface_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DialogDBusInterfaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dialog_dbus_interface_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DialogDBusInterface), 0, (GInstanceInitFunc) dialog_dbus_interface_instance_init, NULL };
		GType dialog_dbus_interface_type_id;
		dialog_dbus_interface_type_id = g_type_register_static (G_TYPE_OBJECT, "DialogDBusInterface", &g_define_type_info, 0);
		g_type_set_qdata (dialog_dbus_interface_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) dialog_dbus_interface_register_object);
		g_once_init_leave (&dialog_dbus_interface_type_id__volatile, dialog_dbus_interface_type_id);
	}
	return dialog_dbus_interface_type_id__volatile;
}


static void _dbus_dialog_dbus_interface_open (DialogDBusInterface* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	guint32 type = 0U;
	GVariant* _tmp218_;
	guint32 timestamp = 0U;
	GVariant* _tmp219_;
	guint32 seconds_to_stay_open = 0U;
	GVariant* _tmp220_;
	char** inhibitor_object_paths = NULL;
	int inhibitor_object_paths_length1 = 0;
	GVariant* _tmp221_;
	char** _tmp222_;
	int _tmp222__length;
	int _tmp222__size;
	int _tmp222__length1;
	GVariantIter _tmp223_;
	GVariant* _tmp224_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp218_ = g_variant_iter_next_value (&_arguments_iter);
	type = g_variant_get_uint32 (_tmp218_);
	g_variant_unref (_tmp218_);
	_tmp219_ = g_variant_iter_next_value (&_arguments_iter);
	timestamp = g_variant_get_uint32 (_tmp219_);
	g_variant_unref (_tmp219_);
	_tmp220_ = g_variant_iter_next_value (&_arguments_iter);
	seconds_to_stay_open = g_variant_get_uint32 (_tmp220_);
	g_variant_unref (_tmp220_);
	_tmp221_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp222_ = g_new (char*, 5);
	_tmp222__length = 0;
	_tmp222__size = 4;
	_tmp222__length1 = 0;
	g_variant_iter_init (&_tmp223_, _tmp221_);
	for (; (_tmp224_ = g_variant_iter_next_value (&_tmp223_)) != NULL; _tmp222__length1++) {
		if (_tmp222__size == _tmp222__length) {
			_tmp222__size = 2 * _tmp222__size;
			_tmp222_ = g_renew (char*, _tmp222_, _tmp222__size + 1);
		}
		_tmp222_[_tmp222__length++] = g_variant_dup_string (_tmp224_, NULL);
		g_variant_unref (_tmp224_);
	}
	inhibitor_object_paths_length1 = _tmp222__length1;
	_tmp222_[_tmp222__length] = NULL;
	inhibitor_object_paths = _tmp222_;
	g_variant_unref (_tmp221_);
	dialog_dbus_interface_open (self, type, timestamp, seconds_to_stay_open, inhibitor_object_paths, inhibitor_object_paths_length1);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	inhibitor_object_paths = (_vala_array_free (inhibitor_object_paths, inhibitor_object_paths_length1, (GDestroyNotify) g_free), NULL);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dialog_dbus_interface_close (DialogDBusInterface* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	dialog_dbus_interface_close (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void dialog_dbus_interface_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "Open") == 0) {
		_dbus_dialog_dbus_interface_open (object, parameters, invocation);
	} else if (strcmp (method_name, "Close") == 0) {
		_dbus_dialog_dbus_interface_close (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* dialog_dbus_interface_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean dialog_dbus_interface_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_dialog_dbus_interface_open_dialog (GObject* _sender, guint32 type, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (type));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.EndSessionDialog", "OpenDialog", _arguments, NULL);
}


static void _dbus_dialog_dbus_interface_close_dialog (GObject* _sender, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.SessionManager.EndSessionDialog", "CloseDialog", _arguments, NULL);
}


guint dialog_dbus_interface_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_dialog_dbus_interface_dbus_interface_info), &_dialog_dbus_interface_dbus_interface_vtable, data, _dialog_dbus_interface_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "open-dialog", (GCallback) _dbus_dialog_dbus_interface_open_dialog, data);
	g_signal_connect (object, "close-dialog", (GCallback) _dbus_dialog_dbus_interface_close_dialog, data);
	return result;
}


static void _dialog_dbus_interface_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_dialog_dbus_interface_open_dialog, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_dialog_dbus_interface_close_dialog, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



