/* idle-monitor.c generated by valac 0.30.1, the Vala compiler
 * generated from idle-monitor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include "X11/extensions/sync.h"
#include <gdk/gdk.h>
#include <gdk/gdkx.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_IDLE_MONITOR (idle_monitor_get_type ())
#define IDLE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDLE_MONITOR, IdleMonitor))
#define IDLE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDLE_MONITOR, IdleMonitorClass))
#define IS_IDLE_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDLE_MONITOR))
#define IS_IDLE_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDLE_MONITOR))
#define IDLE_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDLE_MONITOR, IdleMonitorClass))

typedef struct _IdleMonitor IdleMonitor;
typedef struct _IdleMonitorClass IdleMonitorClass;
typedef struct _IdleMonitorPrivate IdleMonitorPrivate;

#define TYPE_IDLE_MONITOR_WATCH (idle_monitor_watch_get_type ())
#define IDLE_MONITOR_WATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDLE_MONITOR_WATCH, IdleMonitorWatch))
#define IDLE_MONITOR_WATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDLE_MONITOR_WATCH, IdleMonitorWatchClass))
#define IS_IDLE_MONITOR_WATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDLE_MONITOR_WATCH))
#define IS_IDLE_MONITOR_WATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDLE_MONITOR_WATCH))
#define IDLE_MONITOR_WATCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDLE_MONITOR_WATCH, IdleMonitorWatchClass))

typedef struct _IdleMonitorWatch IdleMonitorWatch;
typedef struct _IdleMonitorWatchClass IdleMonitorWatchClass;
typedef struct _IdleMonitorWatchPrivate IdleMonitorWatchPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _idle_monitor_watch_unref0(var) ((var == NULL) ? NULL : (var = (idle_monitor_watch_unref (var), NULL)))
typedef struct _ParamSpecIdleMonitor ParamSpecIdleMonitor;
typedef struct _ParamSpecIdleMonitorWatch ParamSpecIdleMonitorWatch;

typedef void (*IdleMonitorWatchFunc) (IdleMonitor* monitor, guint id, void* user_data);
struct _IdleMonitor {
	GTypeInstance parent_instance;
	volatile int ref_count;
	IdleMonitorPrivate * priv;
};

struct _IdleMonitorClass {
	GTypeClass parent_class;
	void (*finalize) (IdleMonitor *self);
};

struct _IdleMonitorPrivate {
	Display* display;
	GHashTable* watches;
	GHashTable* alarms;
	gint sync_event_base;
	XID counter;
	XID user_active_alarm;
	gint serial;
};

struct _IdleMonitorWatch {
	GTypeInstance parent_instance;
	volatile int ref_count;
	IdleMonitorWatchPrivate * priv;
	guint id;
	IdleMonitorWatchFunc callback;
	gpointer callback_target;
	XID xalarm;
};

struct _IdleMonitorWatchClass {
	GTypeClass parent_class;
	void (*finalize) (IdleMonitorWatch *self);
};

struct _ParamSpecIdleMonitor {
	GParamSpec parent_instance;
};

struct _ParamSpecIdleMonitorWatch {
	GParamSpec parent_instance;
};


static gpointer idle_monitor_parent_class = NULL;
static gpointer idle_monitor_watch_parent_class = NULL;

gpointer idle_monitor_ref (gpointer instance);
void idle_monitor_unref (gpointer instance);
GParamSpec* param_spec_idle_monitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_idle_monitor (GValue* value, gpointer v_object);
void value_take_idle_monitor (GValue* value, gpointer v_object);
gpointer value_get_idle_monitor (const GValue* value);
GType idle_monitor_get_type (void) G_GNUC_CONST;
gpointer idle_monitor_watch_ref (gpointer instance);
void idle_monitor_watch_unref (gpointer instance);
GParamSpec* param_spec_idle_monitor_watch (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_idle_monitor_watch (GValue* value, gpointer v_object);
void value_take_idle_monitor_watch (GValue* value, gpointer v_object);
gpointer value_get_idle_monitor_watch (const GValue* value);
GType idle_monitor_watch_get_type (void) G_GNUC_CONST;
#define IDLE_MONITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IDLE_MONITOR, IdleMonitorPrivate))
enum  {
	IDLE_MONITOR_DUMMY_PROPERTY
};
void idle_monitor_remove_watch (IdleMonitor* self, guint id);
static GdkFilterReturn idle_monitor_xevent_filter (IdleMonitor* self, GdkXEvent* xevent, GdkEvent* event);
static GdkFilterReturn _idle_monitor_xevent_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self);
IdleMonitor* idle_monitor_new (void);
IdleMonitor* idle_monitor_construct (GType object_type);
static void _idle_monitor_watch_unref0_ (gpointer var);
static void idle_monitor_init_xsync (IdleMonitor* self);
guint idle_monitor_add_idle_watch (IdleMonitor* self, guint64 interval_msec, IdleMonitorWatchFunc callback, void* callback_target);
static IdleMonitorWatch* idle_monitor_make_watch (IdleMonitor* self, XID xalarm, IdleMonitorWatchFunc callback, void* callback_target);
static XID idle_monitor_xsync_alarm_set (IdleMonitor* self, XSyncTestType test_type, guint64 interval, gboolean want_events);
guint idle_monitor_add_user_active_watch (IdleMonitor* self, IdleMonitorWatchFunc callback, void* callback_target);
static void idle_monitor_set_alarm_enabled (IdleMonitor* self, Display* dpy, XID alarm, gboolean enabled);
static XID idle_monitor_find_idletime_counter (IdleMonitor* self);
static void idle_monitor_handle_alarm_notify_event (IdleMonitor* self, XSyncAlarmNotifyEvent* alarm_event);
IdleMonitorWatch* idle_monitor_watch_new (void);
IdleMonitorWatch* idle_monitor_watch_construct (GType object_type);
static guint32 idle_monitor_get_next_watch_serial (IdleMonitor* self);
static void idle_monitor_ensure_alarm_rescheduled (IdleMonitor* self, Display* dpy, XID alarm);
static void idle_monitor_fire_watch (IdleMonitor* self, IdleMonitorWatch* watch, XID alarm);
static void idle_monitor_finalize (IdleMonitor* obj);
enum  {
	IDLE_MONITOR_WATCH_DUMMY_PROPERTY
};
static void idle_monitor_watch_finalize (IdleMonitorWatch* obj);


static GdkFilterReturn _idle_monitor_xevent_filter_gdk_filter_func (GdkXEvent* xevent, GdkEvent* event, gpointer self) {
	GdkFilterReturn result;
	result = idle_monitor_xevent_filter ((IdleMonitor*) self, xevent, event);
	return result;
}


static void _idle_monitor_watch_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (idle_monitor_watch_unref (var), NULL));
}


IdleMonitor* idle_monitor_construct (GType object_type) {
	IdleMonitor* self = NULL;
	GHashTable* _tmp0_ = NULL;
	GHashTable* _tmp1_ = NULL;
	self = (IdleMonitor*) g_type_create_instance (object_type);
	_tmp0_ = g_hash_table_new_full (NULL, NULL, NULL, _idle_monitor_watch_unref0_);
	_g_hash_table_unref0 (self->priv->watches);
	self->priv->watches = _tmp0_;
	_tmp1_ = g_hash_table_new_full (NULL, NULL, NULL, NULL);
	_g_hash_table_unref0 (self->priv->alarms);
	self->priv->alarms = _tmp1_;
	idle_monitor_init_xsync (self);
	return self;
}


IdleMonitor* idle_monitor_new (void) {
	return idle_monitor_construct (TYPE_IDLE_MONITOR);
}


guint idle_monitor_add_idle_watch (IdleMonitor* self, guint64 interval_msec, IdleMonitorWatchFunc callback, void* callback_target) {
	guint result = 0U;
	IdleMonitorWatch* watch = NULL;
	guint64 _tmp0_ = 0ULL;
	XID _tmp1_ = 0;
	IdleMonitorWatchFunc _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	IdleMonitorWatch* _tmp3_ = NULL;
	GHashTable* _tmp4_ = NULL;
	XID _tmp5_ = 0;
	guint _tmp6_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = interval_msec;
	_tmp1_ = idle_monitor_xsync_alarm_set (self, XSyncPositiveTransition, _tmp0_, TRUE);
	_tmp2_ = callback;
	_tmp2__target = callback_target;
	_tmp3_ = idle_monitor_make_watch (self, _tmp1_, _tmp2_, _tmp2__target);
	watch = _tmp3_;
	_tmp4_ = self->priv->alarms;
	_tmp5_ = watch->xalarm;
	g_hash_table_add (_tmp4_, (gpointer) ((guintptr) ((guint32) _tmp5_)));
	_tmp6_ = watch->id;
	result = _tmp6_;
	_idle_monitor_watch_unref0 (watch);
	return result;
}


guint idle_monitor_add_user_active_watch (IdleMonitor* self, IdleMonitorWatchFunc callback, void* callback_target) {
	guint result = 0U;
	Display* _tmp0_ = NULL;
	XID _tmp1_ = 0;
	IdleMonitorWatch* watch = NULL;
	XID _tmp2_ = 0;
	IdleMonitorWatchFunc _tmp3_ = NULL;
	void* _tmp3__target = NULL;
	IdleMonitorWatch* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->display;
	_tmp1_ = self->priv->user_active_alarm;
	idle_monitor_set_alarm_enabled (self, _tmp0_, _tmp1_, TRUE);
	_tmp2_ = self->priv->user_active_alarm;
	_tmp3_ = callback;
	_tmp3__target = callback_target;
	_tmp4_ = idle_monitor_make_watch (self, _tmp2_, _tmp3_, _tmp3__target);
	watch = _tmp4_;
	_tmp5_ = watch->id;
	result = _tmp5_;
	_idle_monitor_watch_unref0 (watch);
	return result;
}


static gpointer _idle_monitor_watch_ref0 (gpointer self) {
	return self ? idle_monitor_watch_ref (self) : NULL;
}


void idle_monitor_remove_watch (IdleMonitor* self, guint id) {
	IdleMonitorWatch* watch = NULL;
	GHashTable* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gconstpointer _tmp2_ = NULL;
	IdleMonitorWatch* _tmp3_ = NULL;
	GHashTable* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	IdleMonitorWatch* _tmp6_ = NULL;
	XID _tmp7_ = 0;
	XID _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->watches;
	_tmp1_ = id;
	_tmp2_ = g_hash_table_lookup (_tmp0_, (gpointer) ((guintptr) _tmp1_));
	_tmp3_ = _idle_monitor_watch_ref0 ((IdleMonitorWatch*) _tmp2_);
	watch = _tmp3_;
	_tmp4_ = self->priv->watches;
	_tmp5_ = id;
	g_hash_table_remove (_tmp4_, (gpointer) ((guintptr) _tmp5_));
	_tmp6_ = watch;
	_tmp7_ = _tmp6_->xalarm;
	_tmp8_ = self->priv->user_active_alarm;
	if (_tmp7_ != _tmp8_) {
		Display* _tmp9_ = NULL;
		IdleMonitorWatch* _tmp10_ = NULL;
		XID _tmp11_ = 0;
		_tmp9_ = self->priv->display;
		_tmp10_ = watch;
		_tmp11_ = _tmp10_->xalarm;
		XSyncDestroyAlarm (_tmp9_, _tmp11_);
	}
	_idle_monitor_watch_unref0 (watch);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void idle_monitor_init_xsync (IdleMonitor* self) {
	GdkDisplay* d = NULL;
	GdkDisplay* _tmp0_ = NULL;
	GdkDisplay* _tmp1_ = NULL;
	GdkDisplay* _tmp2_ = NULL;
	GdkDisplay* _tmp3_ = NULL;
	Display* _tmp4_ = NULL;
	gint sync_error_base = 0;
	Status res = {0};
	Display* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	Status _tmp8_ = {0};
	Status _tmp9_ = {0};
	gint major = 0;
	gint minor = 0;
	Display* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	Status _tmp13_ = {0};
	Status _tmp14_ = {0};
	XID _tmp15_ = 0;
	XID _tmp16_ = 0;
	XID _tmp17_ = 0;
	GdkWindow* w = NULL;
	GdkWindow* _tmp18_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	d = _tmp1_;
	_tmp2_ = d;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, gdk_x11_display_get_type ())) {
		g_warning ("idle-monitor.vala:59: Only support idle monitor under X");
		_g_object_unref0 (d);
		return;
	}
	_tmp3_ = d;
	_tmp4_ = gdk_x11_display_get_xdisplay (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp3_) : NULL);
	self->priv->display = _tmp4_;
	_tmp5_ = self->priv->display;
	_tmp8_ = XSyncQueryExtension (_tmp5_, &_tmp6_, &_tmp7_);
	self->priv->sync_event_base = _tmp6_;
	sync_error_base = _tmp7_;
	res = _tmp8_;
	_tmp9_ = res;
	if (_tmp9_ == ((Status) 0)) {
		g_warning ("idle-monitor.vala:68: IdleMonitor: Sync extension not present");
		_g_object_unref0 (d);
		return;
	}
	_tmp10_ = self->priv->display;
	_tmp13_ = XSyncInitialize (_tmp10_, &_tmp11_, &_tmp12_);
	major = _tmp11_;
	minor = _tmp12_;
	res = _tmp13_;
	_tmp14_ = res;
	if (_tmp14_ == ((Status) 0)) {
		g_warning ("idle-monitor.vala:76: IdleMonitor: Unable to initialize Sync extension");
		_g_object_unref0 (d);
		return;
	}
	_tmp15_ = idle_monitor_find_idletime_counter (self);
	self->priv->counter = _tmp15_;
	_tmp16_ = self->priv->counter;
	if (_tmp16_ == None) {
		_g_object_unref0 (d);
		return;
	}
	_tmp17_ = idle_monitor_xsync_alarm_set (self, XSyncNegativeTransition, (guint64) 1, FALSE);
	self->priv->user_active_alarm = _tmp17_;
	w = NULL;
	_tmp18_ = w;
	gdk_window_add_filter (_tmp18_, _idle_monitor_xevent_filter_gdk_filter_func, self);
	_g_object_unref0 (w);
	_g_object_unref0 (d);
}


static GdkFilterReturn idle_monitor_xevent_filter (IdleMonitor* self, GdkXEvent* xevent, GdkEvent* event) {
	GdkFilterReturn result = 0;
	XEvent* ev = NULL;
	GdkXEvent* _tmp0_ = NULL;
	XEvent* _tmp1_ = NULL;
	XAnyEvent _tmp2_ = {0};
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	XSyncAlarmNotifyEvent* alarm_event = NULL;
	GdkXEvent* _tmp6_ = NULL;
	XSyncAlarmNotifyEvent* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (xevent != NULL, 0);
	g_return_val_if_fail (event != NULL, 0);
	_tmp0_ = xevent;
	ev = (XEvent*) _tmp0_;
	_tmp1_ = ev;
	_tmp2_ = (*_tmp1_).xany;
	_tmp3_ = _tmp2_.type;
	_tmp4_ = self->priv->sync_event_base;
	_tmp5_ = XSyncAlarmNotify;
	if (_tmp3_ != (_tmp4_ + _tmp5_)) {
		result = GDK_FILTER_CONTINUE;
		return result;
	}
	_tmp6_ = xevent;
	alarm_event = (XSyncAlarmNotifyEvent*) _tmp6_;
	_tmp7_ = alarm_event;
	idle_monitor_handle_alarm_notify_event (self, _tmp7_);
	result = GDK_FILTER_CONTINUE;
	return result;
}


static IdleMonitorWatch* idle_monitor_make_watch (IdleMonitor* self, XID xalarm, IdleMonitorWatchFunc callback, void* callback_target) {
	IdleMonitorWatch* result = NULL;
	IdleMonitorWatch* watch = NULL;
	IdleMonitorWatch* _tmp0_ = NULL;
	guint32 _tmp1_ = 0U;
	IdleMonitorWatchFunc _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	XID _tmp3_ = 0;
	GHashTable* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	IdleMonitorWatch* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = idle_monitor_watch_new ();
	watch = _tmp0_;
	_tmp1_ = idle_monitor_get_next_watch_serial (self);
	watch->id = (guint) _tmp1_;
	_tmp2_ = callback;
	_tmp2__target = callback_target;
	watch->callback = _tmp2_;
	watch->callback_target = _tmp2__target;
	_tmp3_ = xalarm;
	watch->xalarm = _tmp3_;
	_tmp4_ = self->priv->watches;
	_tmp5_ = watch->id;
	_tmp6_ = _idle_monitor_watch_ref0 (watch);
	g_hash_table_insert (_tmp4_, (gpointer) ((guintptr) _tmp5_), _tmp6_);
	result = watch;
	return result;
}


static XID idle_monitor_xsync_alarm_set (IdleMonitor* self, XSyncTestType test_type, guint64 interval, gboolean want_events) {
	XID result = 0;
	XSyncAlarmAttributes attr = {0};
	XSyncValue delta = {0};
	XSyncValue _tmp0_ = {0};
	XID _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	guint64 _tmp3_ = 0ULL;
	guint64 _tmp4_ = 0ULL;
	XSyncValue _tmp5_ = {0};
	XSyncTestType _tmp6_ = 0;
	Display* _tmp7_ = NULL;
	XSyncAlarmAttributes _tmp8_ = {0};
	XID _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	memset (&attr, 0, sizeof (XSyncAlarmAttributes));
	XSyncIntToValue (&_tmp0_, 0);
	delta = _tmp0_;
	_tmp1_ = self->priv->counter;
	attr.trigger.counter = _tmp1_;
	attr.trigger.value_type = XSyncAbsolute;
	attr.delta = delta;
	_tmp2_ = want_events;
	attr.events = _tmp2_;
	_tmp3_ = interval;
	_tmp4_ = interval;
	XSyncIntsToValue (&_tmp5_, (guint) _tmp3_, (gint) (_tmp4_ >> 32));
	attr.trigger.wait_value = _tmp5_;
	_tmp6_ = test_type;
	attr.trigger.test_type = _tmp6_;
	_tmp7_ = self->priv->display;
	_tmp8_ = attr;
	_tmp9_ = XSyncCreateAlarm (_tmp7_, ((((XSyncCACounter | XSyncCAValueType) | XSyncCATestType) | XSyncCAValue) | XSyncCADelta) | XSyncCAEvents, &_tmp8_);
	result = _tmp9_;
	return result;
}


static void idle_monitor_ensure_alarm_rescheduled (IdleMonitor* self, Display* dpy, XID alarm) {
	XSyncAlarmAttributes attr = {0};
	Display* _tmp0_ = NULL;
	XID _tmp1_ = 0;
	XSyncAlarmAttributes _tmp2_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (dpy != NULL);
	memset (&attr, 0, sizeof (XSyncAlarmAttributes));
	_tmp0_ = dpy;
	_tmp1_ = alarm;
	_tmp2_ = attr;
	XSyncChangeAlarm (_tmp0_, _tmp1_, 0, &_tmp2_);
}


static void idle_monitor_set_alarm_enabled (IdleMonitor* self, Display* dpy, XID alarm, gboolean enabled) {
	XSyncAlarmAttributes attr = {0};
	gboolean _tmp0_ = FALSE;
	Display* _tmp1_ = NULL;
	XID _tmp2_ = 0;
	XSyncAlarmAttributes _tmp3_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (dpy != NULL);
	memset (&attr, 0, sizeof (XSyncAlarmAttributes));
	_tmp0_ = enabled;
	attr.events = _tmp0_;
	_tmp1_ = dpy;
	_tmp2_ = alarm;
	_tmp3_ = attr;
	XSyncChangeAlarm (_tmp1_, _tmp2_, XSyncCAEvents, &_tmp3_);
}


static void idle_monitor_handle_alarm_notify_event (IdleMonitor* self, XSyncAlarmNotifyEvent* alarm_event) {
	XSyncAlarmNotifyEvent* _tmp0_ = NULL;
	XSyncAlarmState _tmp1_ = 0;
	XID alarm = 0;
	XSyncAlarmNotifyEvent* _tmp2_ = NULL;
	XID _tmp3_ = 0;
	gboolean has_alarm = FALSE;
	XID _tmp4_ = 0;
	XID _tmp5_ = 0;
	gboolean _tmp13_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = alarm_event;
	_tmp1_ = (*_tmp0_).state;
	if (_tmp1_ != XSyncAlarmActive) {
		return;
	}
	_tmp2_ = alarm_event;
	_tmp3_ = (*_tmp2_).alarm;
	alarm = _tmp3_;
	has_alarm = FALSE;
	_tmp4_ = alarm;
	_tmp5_ = self->priv->user_active_alarm;
	if (_tmp4_ == _tmp5_) {
		Display* _tmp6_ = NULL;
		XID _tmp7_ = 0;
		_tmp6_ = self->priv->display;
		_tmp7_ = alarm;
		idle_monitor_set_alarm_enabled (self, _tmp6_, _tmp7_, FALSE);
		has_alarm = TRUE;
	} else {
		GHashTable* _tmp8_ = NULL;
		XID _tmp9_ = 0;
		gboolean _tmp10_ = FALSE;
		_tmp8_ = self->priv->alarms;
		_tmp9_ = alarm;
		_tmp10_ = g_hash_table_contains (_tmp8_, (gpointer) ((guintptr) ((guint32) _tmp9_)));
		if (_tmp10_) {
			Display* _tmp11_ = NULL;
			XID _tmp12_ = 0;
			_tmp11_ = self->priv->display;
			_tmp12_ = alarm;
			idle_monitor_ensure_alarm_rescheduled (self, _tmp11_, _tmp12_);
			has_alarm = TRUE;
		}
	}
	_tmp13_ = has_alarm;
	if (_tmp13_) {
		GHashTable* _tmp14_ = NULL;
		GList* _tmp15_ = NULL;
		_tmp14_ = self->priv->watches;
		_tmp15_ = g_hash_table_get_values (_tmp14_);
		{
			GList* watch_collection = NULL;
			GList* watch_it = NULL;
			watch_collection = _tmp15_;
			for (watch_it = watch_collection; watch_it != NULL; watch_it = watch_it->next) {
				IdleMonitorWatch* watch = NULL;
				watch = (IdleMonitorWatch*) watch_it->data;
				{
					IdleMonitorWatch* _tmp16_ = NULL;
					XID _tmp17_ = 0;
					_tmp16_ = watch;
					_tmp17_ = alarm;
					idle_monitor_fire_watch (self, _tmp16_, _tmp17_);
				}
			}
			_g_list_free0 (watch_collection);
		}
	}
}


static void idle_monitor_fire_watch (IdleMonitor* self, IdleMonitorWatch* watch, XID alarm) {
	IdleMonitorWatch* _tmp0_ = NULL;
	XID _tmp1_ = 0;
	XID _tmp2_ = 0;
	IdleMonitorWatch* _tmp3_ = NULL;
	IdleMonitorWatchFunc _tmp4_ = NULL;
	void* _tmp4__target = NULL;
	IdleMonitorWatch* _tmp9_ = NULL;
	XID _tmp10_ = 0;
	XID _tmp11_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (watch != NULL);
	_tmp0_ = watch;
	_tmp1_ = _tmp0_->xalarm;
	_tmp2_ = alarm;
	if (_tmp1_ != _tmp2_) {
		return;
	}
	_tmp3_ = watch;
	_tmp4_ = _tmp3_->callback;
	_tmp4__target = _tmp3_->callback_target;
	if (_tmp4_ != NULL) {
		IdleMonitorWatch* _tmp5_ = NULL;
		IdleMonitorWatchFunc _tmp6_ = NULL;
		void* _tmp6__target = NULL;
		IdleMonitorWatch* _tmp7_ = NULL;
		guint _tmp8_ = 0U;
		_tmp5_ = watch;
		_tmp6_ = _tmp5_->callback;
		_tmp6__target = _tmp5_->callback_target;
		_tmp7_ = watch;
		_tmp8_ = _tmp7_->id;
		_tmp6_ (self, _tmp8_, _tmp6__target);
	}
	_tmp9_ = watch;
	_tmp10_ = _tmp9_->xalarm;
	_tmp11_ = self->priv->user_active_alarm;
	if (_tmp10_ == _tmp11_) {
		IdleMonitorWatch* _tmp12_ = NULL;
		guint _tmp13_ = 0U;
		_tmp12_ = watch;
		_tmp13_ = _tmp12_->id;
		idle_monitor_remove_watch (self, _tmp13_);
	}
}


static XID idle_monitor_find_idletime_counter (IdleMonitor* self) {
	XID result = 0;
	XID counter = 0;
	gint ncounters = 0;
	XSyncSystemCounter* counters = NULL;
	Display* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	XSyncSystemCounter* _tmp2_ = NULL;
	XSyncSystemCounter* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	counter = None;
	_tmp0_ = self->priv->display;
	_tmp2_ = XSyncListSystemCounters (_tmp0_, &_tmp1_);
	ncounters = _tmp1_;
	counters = _tmp2_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				gint _tmp6_ = 0;
				gboolean _tmp7_ = FALSE;
				XSyncSystemCounter* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				XSyncSystemCounter _tmp10_ = {0};
				const gchar* _tmp11_ = NULL;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = ncounters;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp8_ = counters;
				_tmp9_ = i;
				_tmp10_ = _tmp8_[_tmp9_];
				_tmp11_ = _tmp10_.name;
				if (_tmp11_ != NULL) {
					GCompareFunc _tmp12_ = NULL;
					XSyncSystemCounter* _tmp13_ = NULL;
					gint _tmp14_ = 0;
					XSyncSystemCounter _tmp15_ = {0};
					const gchar* _tmp16_ = NULL;
					gint _tmp17_ = 0;
					_tmp12_ = g_strcmp0;
					_tmp13_ = counters;
					_tmp14_ = i;
					_tmp15_ = _tmp13_[_tmp14_];
					_tmp16_ = _tmp15_.name;
					_tmp17_ = _tmp12_ (_tmp16_, "IDLETIME");
					_tmp7_ = _tmp17_ == 0;
				} else {
					_tmp7_ = FALSE;
				}
				if (_tmp7_) {
					XSyncSystemCounter* _tmp18_ = NULL;
					gint _tmp19_ = 0;
					XSyncSystemCounter _tmp20_ = {0};
					XID _tmp21_ = 0;
					_tmp18_ = counters;
					_tmp19_ = i;
					_tmp20_ = _tmp18_[_tmp19_];
					_tmp21_ = _tmp20_.counter;
					counter = _tmp21_;
					break;
				}
			}
		}
	}
	_tmp22_ = counters;
	XSyncFreeSystemCounterList (_tmp22_);
	result = counter;
	return result;
}


static guint32 idle_monitor_get_next_watch_serial (IdleMonitor* self) {
	guint32 result = 0U;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0U);
	g_atomic_int_inc ((volatile gint *) (&self->priv->serial));
	_tmp0_ = self->priv->serial;
	result = (guint32) _tmp0_;
	return result;
}


static void value_idle_monitor_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_idle_monitor_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		idle_monitor_unref (value->data[0].v_pointer);
	}
}


static void value_idle_monitor_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = idle_monitor_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_idle_monitor_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_idle_monitor_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		IdleMonitor* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = idle_monitor_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_idle_monitor_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	IdleMonitor** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = idle_monitor_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_idle_monitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecIdleMonitor* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_IDLE_MONITOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_idle_monitor (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR), NULL);
	return value->data[0].v_pointer;
}


void value_set_idle_monitor (GValue* value, gpointer v_object) {
	IdleMonitor* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_IDLE_MONITOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		idle_monitor_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		idle_monitor_unref (old);
	}
}


void value_take_idle_monitor (GValue* value, gpointer v_object) {
	IdleMonitor* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_IDLE_MONITOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		idle_monitor_unref (old);
	}
}


static void idle_monitor_class_init (IdleMonitorClass * klass) {
	idle_monitor_parent_class = g_type_class_peek_parent (klass);
	((IdleMonitorClass *) klass)->finalize = idle_monitor_finalize;
	g_type_class_add_private (klass, sizeof (IdleMonitorPrivate));
}


static void idle_monitor_instance_init (IdleMonitor * self) {
	self->priv = IDLE_MONITOR_GET_PRIVATE (self);
	self->priv->serial = 0;
	self->ref_count = 1;
}


static void idle_monitor_finalize (IdleMonitor* obj) {
	IdleMonitor * self;
	GHashTable* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	XID _tmp4_ = 0;
	GdkWindow* w = NULL;
	GdkWindow* _tmp7_ = NULL;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IDLE_MONITOR, IdleMonitor);
	g_signal_handlers_destroy (self);
	_tmp0_ = self->priv->watches;
	_tmp1_ = g_hash_table_get_values (_tmp0_);
	{
		GList* watch_collection = NULL;
		GList* watch_it = NULL;
		watch_collection = _tmp1_;
		for (watch_it = watch_collection; watch_it != NULL; watch_it = watch_it->next) {
			IdleMonitorWatch* watch = NULL;
			watch = (IdleMonitorWatch*) watch_it->data;
			{
				IdleMonitorWatch* _tmp2_ = NULL;
				guint _tmp3_ = 0U;
				_tmp2_ = watch;
				_tmp3_ = _tmp2_->id;
				idle_monitor_remove_watch (self, _tmp3_);
			}
		}
		_g_list_free0 (watch_collection);
	}
	_tmp4_ = self->priv->user_active_alarm;
	if (_tmp4_ != None) {
		Display* _tmp5_ = NULL;
		XID _tmp6_ = 0;
		_tmp5_ = self->priv->display;
		_tmp6_ = self->priv->user_active_alarm;
		XSyncDestroyAlarm (_tmp5_, _tmp6_);
	}
	w = NULL;
	_tmp7_ = w;
	gdk_window_remove_filter (_tmp7_, _idle_monitor_xevent_filter_gdk_filter_func, self);
	_g_object_unref0 (w);
	_g_hash_table_unref0 (self->priv->watches);
	_g_hash_table_unref0 (self->priv->alarms);
}


GType idle_monitor_get_type (void) {
	static volatile gsize idle_monitor_type_id__volatile = 0;
	if (g_once_init_enter (&idle_monitor_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_idle_monitor_init, value_idle_monitor_free_value, value_idle_monitor_copy_value, value_idle_monitor_peek_pointer, "p", value_idle_monitor_collect_value, "p", value_idle_monitor_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (IdleMonitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) idle_monitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IdleMonitor), 0, (GInstanceInitFunc) idle_monitor_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType idle_monitor_type_id;
		idle_monitor_type_id = g_type_register_fundamental (g_type_fundamental_next (), "IdleMonitor", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&idle_monitor_type_id__volatile, idle_monitor_type_id);
	}
	return idle_monitor_type_id__volatile;
}


gpointer idle_monitor_ref (gpointer instance) {
	IdleMonitor* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void idle_monitor_unref (gpointer instance) {
	IdleMonitor* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		IDLE_MONITOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


IdleMonitorWatch* idle_monitor_watch_construct (GType object_type) {
	IdleMonitorWatch* self = NULL;
	self = (IdleMonitorWatch*) g_type_create_instance (object_type);
	return self;
}


IdleMonitorWatch* idle_monitor_watch_new (void) {
	return idle_monitor_watch_construct (TYPE_IDLE_MONITOR_WATCH);
}


static void value_idle_monitor_watch_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_idle_monitor_watch_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		idle_monitor_watch_unref (value->data[0].v_pointer);
	}
}


static void value_idle_monitor_watch_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = idle_monitor_watch_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_idle_monitor_watch_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_idle_monitor_watch_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		IdleMonitorWatch* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = idle_monitor_watch_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_idle_monitor_watch_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	IdleMonitorWatch** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = idle_monitor_watch_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_idle_monitor_watch (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecIdleMonitorWatch* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_IDLE_MONITOR_WATCH), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_idle_monitor_watch (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR_WATCH), NULL);
	return value->data[0].v_pointer;
}


void value_set_idle_monitor_watch (GValue* value, gpointer v_object) {
	IdleMonitorWatch* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR_WATCH));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_IDLE_MONITOR_WATCH));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		idle_monitor_watch_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		idle_monitor_watch_unref (old);
	}
}


void value_take_idle_monitor_watch (GValue* value, gpointer v_object) {
	IdleMonitorWatch* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_IDLE_MONITOR_WATCH));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_IDLE_MONITOR_WATCH));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		idle_monitor_watch_unref (old);
	}
}


static void idle_monitor_watch_class_init (IdleMonitorWatchClass * klass) {
	idle_monitor_watch_parent_class = g_type_class_peek_parent (klass);
	((IdleMonitorWatchClass *) klass)->finalize = idle_monitor_watch_finalize;
}


static void idle_monitor_watch_instance_init (IdleMonitorWatch * self) {
	self->ref_count = 1;
}


static void idle_monitor_watch_finalize (IdleMonitorWatch* obj) {
	IdleMonitorWatch * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IDLE_MONITOR_WATCH, IdleMonitorWatch);
	g_signal_handlers_destroy (self);
}


GType idle_monitor_watch_get_type (void) {
	static volatile gsize idle_monitor_watch_type_id__volatile = 0;
	if (g_once_init_enter (&idle_monitor_watch_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_idle_monitor_watch_init, value_idle_monitor_watch_free_value, value_idle_monitor_watch_copy_value, value_idle_monitor_watch_peek_pointer, "p", value_idle_monitor_watch_collect_value, "p", value_idle_monitor_watch_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (IdleMonitorWatchClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) idle_monitor_watch_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IdleMonitorWatch), 0, (GInstanceInitFunc) idle_monitor_watch_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType idle_monitor_watch_type_id;
		idle_monitor_watch_type_id = g_type_register_fundamental (g_type_fundamental_next (), "IdleMonitorWatch", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&idle_monitor_watch_type_id__volatile, idle_monitor_watch_type_id);
	}
	return idle_monitor_watch_type_id__volatile;
}


gpointer idle_monitor_watch_ref (gpointer instance) {
	IdleMonitorWatch* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void idle_monitor_watch_unref (gpointer instance) {
	IdleMonitorWatch* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		IDLE_MONITOR_WATCH_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



