/* cairo-utils.c generated by valac 0.30.1, the Vala compiler
 * generated from cairo-utils.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2013 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Marco Trevisan <marco.trevisan@canonical.com>
 *          Mirco "MacSlow" Mueller <mirco.mueller@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR (cairo_utils_exponential_blur_get_type ())
#define CAIRO_UTILS_EXPONENTIAL_BLUR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR, CairoUtilsExponentialBlur))
#define CAIRO_UTILS_EXPONENTIAL_BLUR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR, CairoUtilsExponentialBlurClass))
#define CAIRO_UTILS_IS_EXPONENTIAL_BLUR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR))
#define CAIRO_UTILS_IS_EXPONENTIAL_BLUR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR))
#define CAIRO_UTILS_EXPONENTIAL_BLUR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR, CairoUtilsExponentialBlurClass))

typedef struct _CairoUtilsExponentialBlur CairoUtilsExponentialBlur;
typedef struct _CairoUtilsExponentialBlurClass CairoUtilsExponentialBlurClass;
typedef struct _CairoUtilsExponentialBlurPrivate CairoUtilsExponentialBlurPrivate;
typedef struct _CairoUtilsParamSpecExponentialBlur CairoUtilsParamSpecExponentialBlur;

struct _CairoUtilsExponentialBlur {
	GTypeInstance parent_instance;
	volatile int ref_count;
	CairoUtilsExponentialBlurPrivate * priv;
};

struct _CairoUtilsExponentialBlurClass {
	GTypeClass parent_class;
	void (*finalize) (CairoUtilsExponentialBlur *self);
};

struct _CairoUtilsParamSpecExponentialBlur {
	GParamSpec parent_instance;
};


static gpointer cairo_utils_exponential_blur_parent_class = NULL;

void cairo_utils_rounded_rectangle (cairo_t* c, gdouble x, gdouble y, gdouble width, gdouble height, gdouble radius);
gpointer cairo_utils_exponential_blur_ref (gpointer instance);
void cairo_utils_exponential_blur_unref (gpointer instance);
GParamSpec* cairo_utils_param_spec_exponential_blur (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void cairo_utils_value_set_exponential_blur (GValue* value, gpointer v_object);
void cairo_utils_value_take_exponential_blur (GValue* value, gpointer v_object);
gpointer cairo_utils_value_get_exponential_blur (const GValue* value);
GType cairo_utils_exponential_blur_get_type (void) G_GNUC_CONST;
enum  {
	CAIRO_UTILS_EXPONENTIAL_BLUR_DUMMY_PROPERTY
};
#define CAIRO_UTILS_EXPONENTIAL_BLUR_APREC 16
#define CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC 7
void cairo_utils_exponential_blur_surface (cairo_surface_t* surface, gint radius);
static void cairo_utils_exponential_blur_blur (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint radius);
static void cairo_utils_exponential_blur_blurrow (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint line, gint alpha);
static void cairo_utils_exponential_blur_blurcol (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint x, gint alpha);
static void cairo_utils_exponential_blur_blurinner (guchar* pixel, gint alpha, gint* zR, gint* zG, gint* zB, gint* zA);
CairoUtilsExponentialBlur* cairo_utils_exponential_blur_new (void);
CairoUtilsExponentialBlur* cairo_utils_exponential_blur_construct (GType object_type);
static void cairo_utils_exponential_blur_finalize (CairoUtilsExponentialBlur* obj);


void cairo_utils_rounded_rectangle (cairo_t* c, gdouble x, gdouble y, gdouble width, gdouble height, gdouble radius) {
	gdouble w = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble kappa = 0.0;
	gdouble _tmp4_ = 0.0;
	cairo_t* _tmp5_ = NULL;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	cairo_t* _tmp9_ = NULL;
	cairo_t* _tmp10_ = NULL;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	cairo_t* _tmp15_ = NULL;
	cairo_t* _tmp16_ = NULL;
	gdouble _tmp17_ = 0.0;
	gdouble _tmp18_ = 0.0;
	gdouble _tmp19_ = 0.0;
	gdouble _tmp20_ = 0.0;
	cairo_t* _tmp21_ = NULL;
	cairo_t* _tmp22_ = NULL;
	gdouble _tmp23_ = 0.0;
	gdouble _tmp24_ = 0.0;
	gdouble _tmp25_ = 0.0;
	gdouble _tmp26_ = 0.0;
	cairo_t* _tmp27_ = NULL;
	cairo_t* _tmp28_ = NULL;
	gdouble _tmp29_ = 0.0;
	gdouble _tmp30_ = 0.0;
	gdouble _tmp31_ = 0.0;
	gdouble _tmp32_ = 0.0;
	g_return_if_fail (c != NULL);
	_tmp0_ = width;
	_tmp1_ = radius;
	w = _tmp0_ - (_tmp1_ * 2);
	_tmp2_ = height;
	_tmp3_ = radius;
	h = _tmp2_ - (_tmp3_ * 2);
	_tmp4_ = radius;
	kappa = 0.5522847498 * _tmp4_;
	_tmp5_ = c;
	_tmp6_ = x;
	_tmp7_ = radius;
	_tmp8_ = y;
	cairo_move_to (_tmp5_, _tmp6_ + _tmp7_, _tmp8_);
	_tmp9_ = c;
	cairo_rel_line_to (_tmp9_, w, (gdouble) 0);
	_tmp10_ = c;
	_tmp11_ = radius;
	_tmp12_ = radius;
	_tmp13_ = radius;
	_tmp14_ = radius;
	cairo_rel_curve_to (_tmp10_, kappa, (gdouble) 0, _tmp11_, _tmp12_ - kappa, _tmp13_, _tmp14_);
	_tmp15_ = c;
	cairo_rel_line_to (_tmp15_, (gdouble) 0, h);
	_tmp16_ = c;
	_tmp17_ = radius;
	_tmp18_ = radius;
	_tmp19_ = radius;
	_tmp20_ = radius;
	cairo_rel_curve_to (_tmp16_, (gdouble) 0, kappa, kappa - _tmp17_, _tmp18_, -_tmp19_, _tmp20_);
	_tmp21_ = c;
	cairo_rel_line_to (_tmp21_, -w, (gdouble) 0);
	_tmp22_ = c;
	_tmp23_ = radius;
	_tmp24_ = radius;
	_tmp25_ = radius;
	_tmp26_ = radius;
	cairo_rel_curve_to (_tmp22_, -kappa, (gdouble) 0, -_tmp23_, kappa - _tmp24_, -_tmp25_, -_tmp26_);
	_tmp27_ = c;
	cairo_rel_line_to (_tmp27_, (gdouble) 0, -h);
	_tmp28_ = c;
	_tmp29_ = radius;
	_tmp30_ = radius;
	_tmp31_ = radius;
	_tmp32_ = radius;
	cairo_rel_curve_to (_tmp28_, (gdouble) 0, -kappa, _tmp29_ - kappa, -_tmp30_, _tmp31_, -_tmp32_);
}


void cairo_utils_exponential_blur_surface (cairo_surface_t* surface, gint radius) {
	gint _tmp0_ = 0;
	cairo_surface_t* _tmp1_ = NULL;
	guchar* pixels = NULL;
	cairo_surface_t* _tmp2_ = NULL;
	guchar* _tmp3_ = NULL;
	gint pixels_length1 = 0;
	gint _pixels_size_ = 0;
	gint width = 0;
	cairo_surface_t* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint height = 0;
	cairo_surface_t* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	cairo_format_t format = 0;
	cairo_surface_t* _tmp8_ = NULL;
	cairo_format_t _tmp9_ = 0;
	cairo_format_t _tmp10_ = 0;
	cairo_surface_t* _tmp23_ = NULL;
	g_return_if_fail (surface != NULL);
	_tmp0_ = radius;
	if (_tmp0_ < 1) {
		return;
	}
	_tmp1_ = surface;
	cairo_surface_flush (_tmp1_);
	_tmp2_ = surface;
	_tmp3_ = cairo_image_surface_get_data (_tmp2_);
	pixels = _tmp3_;
	pixels_length1 = -1;
	_pixels_size_ = pixels_length1;
	_tmp4_ = surface;
	_tmp5_ = cairo_image_surface_get_width (_tmp4_);
	width = _tmp5_;
	_tmp6_ = surface;
	_tmp7_ = cairo_image_surface_get_height (_tmp6_);
	height = _tmp7_;
	_tmp8_ = surface;
	_tmp9_ = cairo_image_surface_get_format (_tmp8_);
	format = _tmp9_;
	_tmp10_ = format;
	switch (_tmp10_) {
		case CAIRO_FORMAT_ARGB32:
		{
			guchar* _tmp11_ = NULL;
			gint _tmp11__length1 = 0;
			gint _tmp12_ = 0;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			_tmp11_ = pixels;
			_tmp11__length1 = pixels_length1;
			_tmp12_ = width;
			_tmp13_ = height;
			_tmp14_ = radius;
			cairo_utils_exponential_blur_blur (_tmp11_, _tmp11__length1, _tmp12_, _tmp13_, 4, _tmp14_);
			break;
		}
		case CAIRO_FORMAT_RGB24:
		{
			guchar* _tmp15_ = NULL;
			gint _tmp15__length1 = 0;
			gint _tmp16_ = 0;
			gint _tmp17_ = 0;
			gint _tmp18_ = 0;
			_tmp15_ = pixels;
			_tmp15__length1 = pixels_length1;
			_tmp16_ = width;
			_tmp17_ = height;
			_tmp18_ = radius;
			cairo_utils_exponential_blur_blur (_tmp15_, _tmp15__length1, _tmp16_, _tmp17_, 3, _tmp18_);
			break;
		}
		case CAIRO_FORMAT_A8:
		{
			guchar* _tmp19_ = NULL;
			gint _tmp19__length1 = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			_tmp19_ = pixels;
			_tmp19__length1 = pixels_length1;
			_tmp20_ = width;
			_tmp21_ = height;
			_tmp22_ = radius;
			cairo_utils_exponential_blur_blur (_tmp19_, _tmp19__length1, _tmp20_, _tmp21_, 1, _tmp22_);
			break;
		}
		default:
		{
			break;
		}
	}
	_tmp23_ = surface;
	cairo_surface_mark_dirty (_tmp23_);
}


static void cairo_utils_exponential_blur_blur (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint radius) {
	gint alpha = 0;
	gint _tmp0_ = 0;
	gfloat _tmp1_ = 0.0F;
	_tmp0_ = radius;
	_tmp1_ = expf ((-2.3f) / (_tmp0_ + 1.0f));
	alpha = (gint) ((1 << CAIRO_UTILS_EXPONENTIAL_BLUR_APREC) * (1.0f - _tmp1_));
	{
		gint row = 0;
		row = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				guchar* _tmp6_ = NULL;
				gint _tmp6__length1 = 0;
				gint _tmp7_ = 0;
				gint _tmp8_ = 0;
				gint _tmp9_ = 0;
				gint _tmp10_ = 0;
				gint _tmp11_ = 0;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = row;
					row = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = row;
				_tmp5_ = height;
				if (!(_tmp4_ < _tmp5_)) {
					break;
				}
				_tmp6_ = pixels;
				_tmp6__length1 = pixels_length1;
				_tmp7_ = width;
				_tmp8_ = height;
				_tmp9_ = channels;
				_tmp10_ = row;
				_tmp11_ = alpha;
				cairo_utils_exponential_blur_blurrow (_tmp6_, _tmp6__length1, _tmp7_, _tmp8_, _tmp9_, _tmp10_, _tmp11_);
			}
		}
	}
	{
		gint col = 0;
		col = 0;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				gint _tmp14_ = 0;
				gint _tmp15_ = 0;
				guchar* _tmp16_ = NULL;
				gint _tmp16__length1 = 0;
				gint _tmp17_ = 0;
				gint _tmp18_ = 0;
				gint _tmp19_ = 0;
				gint _tmp20_ = 0;
				gint _tmp21_ = 0;
				if (!_tmp12_) {
					gint _tmp13_ = 0;
					_tmp13_ = col;
					col = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp14_ = col;
				_tmp15_ = width;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = pixels;
				_tmp16__length1 = pixels_length1;
				_tmp17_ = width;
				_tmp18_ = height;
				_tmp19_ = channels;
				_tmp20_ = col;
				_tmp21_ = alpha;
				cairo_utils_exponential_blur_blurcol (_tmp16_, _tmp16__length1, _tmp17_, _tmp18_, _tmp19_, _tmp20_, _tmp21_);
			}
		}
	}
}


static void cairo_utils_exponential_blur_blurrow (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint line, gint alpha) {
	guchar* scanline = NULL;
	guchar* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint zR = 0;
	guchar* _tmp4_ = NULL;
	gint zG = 0;
	guchar* _tmp5_ = NULL;
	gint zB = 0;
	guchar* _tmp6_ = NULL;
	gint zA = 0;
	guchar* _tmp7_ = NULL;
	_tmp0_ = pixels;
	_tmp0__length1 = pixels_length1;
	_tmp1_ = line;
	_tmp2_ = width;
	_tmp3_ = channels;
	scanline = &_tmp0_[(_tmp1_ * _tmp2_) * _tmp3_];
	_tmp4_ = scanline;
	zR = (*_tmp4_) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp5_ = scanline;
	zG = (*(_tmp5_ + 1)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp6_ = scanline;
	zB = (*(_tmp6_ + 2)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp7_ = scanline;
	zA = (*(_tmp7_ + 3)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	{
		gint index = 0;
		index = 0;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				gint _tmp10_ = 0;
				gint _tmp11_ = 0;
				guchar* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				gint _tmp14_ = 0;
				gint _tmp15_ = 0;
				if (!_tmp8_) {
					gint _tmp9_ = 0;
					_tmp9_ = index;
					index = _tmp9_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp10_ = index;
				_tmp11_ = width;
				if (!(_tmp10_ < _tmp11_)) {
					break;
				}
				_tmp12_ = scanline;
				_tmp13_ = index;
				_tmp14_ = channels;
				_tmp15_ = alpha;
				cairo_utils_exponential_blur_blurinner (&_tmp12_[_tmp13_ * _tmp14_], _tmp15_, &zR, &zG, &zB, &zA);
			}
		}
	}
	{
		gint index = 0;
		gint _tmp16_ = 0;
		_tmp16_ = width;
		index = _tmp16_ - 2;
		{
			gboolean _tmp17_ = FALSE;
			_tmp17_ = TRUE;
			while (TRUE) {
				gint _tmp19_ = 0;
				guchar* _tmp20_ = NULL;
				gint _tmp21_ = 0;
				gint _tmp22_ = 0;
				gint _tmp23_ = 0;
				if (!_tmp17_) {
					gint _tmp18_ = 0;
					_tmp18_ = index;
					index = _tmp18_ - 1;
				}
				_tmp17_ = FALSE;
				_tmp19_ = index;
				if (!(_tmp19_ >= 0)) {
					break;
				}
				_tmp20_ = scanline;
				_tmp21_ = index;
				_tmp22_ = channels;
				_tmp23_ = alpha;
				cairo_utils_exponential_blur_blurinner (&_tmp20_[_tmp21_ * _tmp22_], _tmp23_, &zR, &zG, &zB, &zA);
			}
		}
	}
}


static void cairo_utils_exponential_blur_blurcol (guchar* pixels, int pixels_length1, gint width, gint height, gint channels, gint x, gint alpha) {
	guchar* ptr = NULL;
	guchar* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint zR = 0;
	guchar* _tmp3_ = NULL;
	gint zG = 0;
	guchar* _tmp4_ = NULL;
	gint zB = 0;
	guchar* _tmp5_ = NULL;
	gint zA = 0;
	guchar* _tmp6_ = NULL;
	_tmp0_ = pixels;
	_tmp0__length1 = pixels_length1;
	_tmp1_ = x;
	_tmp2_ = channels;
	ptr = &_tmp0_[_tmp1_ * _tmp2_];
	_tmp3_ = ptr;
	zR = (*_tmp3_) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp4_ = ptr;
	zG = (*(_tmp4_ + 1)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp5_ = ptr;
	zB = (*(_tmp5_ + 2)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	_tmp6_ = ptr;
	zA = (*(_tmp6_ + 3)) << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC;
	{
		gint index = 0;
		gint _tmp7_ = 0;
		_tmp7_ = width;
		index = _tmp7_;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				gint _tmp11_ = 0;
				gint _tmp12_ = 0;
				gint _tmp13_ = 0;
				guchar* _tmp14_ = NULL;
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				if (!_tmp8_) {
					gint _tmp9_ = 0;
					gint _tmp10_ = 0;
					_tmp9_ = index;
					_tmp10_ = width;
					index = _tmp9_ + _tmp10_;
				}
				_tmp8_ = FALSE;
				_tmp11_ = index;
				_tmp12_ = height;
				_tmp13_ = width;
				if (!(_tmp11_ < ((_tmp12_ - 1) * _tmp13_))) {
					break;
				}
				_tmp14_ = ptr;
				_tmp15_ = index;
				_tmp16_ = channels;
				_tmp17_ = alpha;
				cairo_utils_exponential_blur_blurinner (&_tmp14_[_tmp15_ * _tmp16_], _tmp17_, &zR, &zG, &zB, &zA);
			}
		}
	}
	{
		gint index = 0;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		_tmp18_ = height;
		_tmp19_ = width;
		index = (_tmp18_ - 2) * _tmp19_;
		{
			gboolean _tmp20_ = FALSE;
			_tmp20_ = TRUE;
			while (TRUE) {
				gint _tmp23_ = 0;
				guchar* _tmp24_ = NULL;
				gint _tmp25_ = 0;
				gint _tmp26_ = 0;
				gint _tmp27_ = 0;
				if (!_tmp20_) {
					gint _tmp21_ = 0;
					gint _tmp22_ = 0;
					_tmp21_ = index;
					_tmp22_ = width;
					index = _tmp21_ - _tmp22_;
				}
				_tmp20_ = FALSE;
				_tmp23_ = index;
				if (!(_tmp23_ >= 0)) {
					break;
				}
				_tmp24_ = ptr;
				_tmp25_ = index;
				_tmp26_ = channels;
				_tmp27_ = alpha;
				cairo_utils_exponential_blur_blurinner (&_tmp24_[_tmp25_ * _tmp26_], _tmp27_, &zR, &zG, &zB, &zA);
			}
		}
	}
}


static void cairo_utils_exponential_blur_blurinner (guchar* pixel, gint alpha, gint* zR, gint* zG, gint* zB, gint* zA) {
	gint R = 0;
	gint G = 0;
	gint B = 0;
	guchar A = '\0';
	guchar* _tmp0_ = NULL;
	guchar* _tmp1_ = NULL;
	guchar* _tmp2_ = NULL;
	guchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	gint _tmp15_ = 0;
	guchar* _tmp16_ = NULL;
	gint _tmp17_ = 0;
	guchar _tmp18_ = '\0';
	guchar* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	guchar _tmp21_ = '\0';
	guchar* _tmp22_ = NULL;
	gint _tmp23_ = 0;
	guchar _tmp24_ = '\0';
	guchar* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	guchar _tmp27_ = '\0';
	_tmp0_ = pixel;
	R = (gint) (*_tmp0_);
	_tmp1_ = pixel;
	G = (gint) (*(_tmp1_ + 1));
	_tmp2_ = pixel;
	B = (gint) (*(_tmp2_ + 2));
	_tmp3_ = pixel;
	A = *(_tmp3_ + 3);
	_tmp4_ = *zR;
	_tmp5_ = alpha;
	_tmp6_ = *zR;
	*zR = _tmp4_ + ((_tmp5_ * ((R << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC) - _tmp6_)) >> CAIRO_UTILS_EXPONENTIAL_BLUR_APREC);
	_tmp7_ = *zG;
	_tmp8_ = alpha;
	_tmp9_ = *zG;
	*zG = _tmp7_ + ((_tmp8_ * ((G << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC) - _tmp9_)) >> CAIRO_UTILS_EXPONENTIAL_BLUR_APREC);
	_tmp10_ = *zB;
	_tmp11_ = alpha;
	_tmp12_ = *zB;
	*zB = _tmp10_ + ((_tmp11_ * ((B << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC) - _tmp12_)) >> CAIRO_UTILS_EXPONENTIAL_BLUR_APREC);
	_tmp13_ = *zA;
	_tmp14_ = alpha;
	_tmp15_ = *zA;
	*zA = _tmp13_ + ((_tmp14_ * ((A << CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC) - _tmp15_)) >> CAIRO_UTILS_EXPONENTIAL_BLUR_APREC);
	_tmp16_ = pixel;
	_tmp17_ = *zR;
	*_tmp16_ = (guchar) (_tmp17_ >> CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC);
	_tmp18_ = *_tmp16_;
	_tmp19_ = pixel;
	_tmp20_ = *zG;
	*(_tmp19_ + 1) = (guchar) (_tmp20_ >> CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC);
	_tmp21_ = *(_tmp19_ + 1);
	_tmp22_ = pixel;
	_tmp23_ = *zB;
	*(_tmp22_ + 2) = (guchar) (_tmp23_ >> CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC);
	_tmp24_ = *(_tmp22_ + 2);
	_tmp25_ = pixel;
	_tmp26_ = *zA;
	*(_tmp25_ + 3) = (guchar) (_tmp26_ >> CAIRO_UTILS_EXPONENTIAL_BLUR_ZPREC);
	_tmp27_ = *(_tmp25_ + 3);
}


CairoUtilsExponentialBlur* cairo_utils_exponential_blur_construct (GType object_type) {
	CairoUtilsExponentialBlur* self = NULL;
	self = (CairoUtilsExponentialBlur*) g_type_create_instance (object_type);
	return self;
}


CairoUtilsExponentialBlur* cairo_utils_exponential_blur_new (void) {
	return cairo_utils_exponential_blur_construct (CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR);
}


static void cairo_utils_value_exponential_blur_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void cairo_utils_value_exponential_blur_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		cairo_utils_exponential_blur_unref (value->data[0].v_pointer);
	}
}


static void cairo_utils_value_exponential_blur_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = cairo_utils_exponential_blur_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer cairo_utils_value_exponential_blur_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* cairo_utils_value_exponential_blur_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		CairoUtilsExponentialBlur* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = cairo_utils_exponential_blur_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* cairo_utils_value_exponential_blur_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	CairoUtilsExponentialBlur** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = cairo_utils_exponential_blur_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* cairo_utils_param_spec_exponential_blur (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	CairoUtilsParamSpecExponentialBlur* spec;
	g_return_val_if_fail (g_type_is_a (object_type, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer cairo_utils_value_get_exponential_blur (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR), NULL);
	return value->data[0].v_pointer;
}


void cairo_utils_value_set_exponential_blur (GValue* value, gpointer v_object) {
	CairoUtilsExponentialBlur* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		cairo_utils_exponential_blur_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		cairo_utils_exponential_blur_unref (old);
	}
}


void cairo_utils_value_take_exponential_blur (GValue* value, gpointer v_object) {
	CairoUtilsExponentialBlur* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		cairo_utils_exponential_blur_unref (old);
	}
}


static void cairo_utils_exponential_blur_class_init (CairoUtilsExponentialBlurClass * klass) {
	cairo_utils_exponential_blur_parent_class = g_type_class_peek_parent (klass);
	((CairoUtilsExponentialBlurClass *) klass)->finalize = cairo_utils_exponential_blur_finalize;
}


static void cairo_utils_exponential_blur_instance_init (CairoUtilsExponentialBlur * self) {
	self->ref_count = 1;
}


static void cairo_utils_exponential_blur_finalize (CairoUtilsExponentialBlur* obj) {
	CairoUtilsExponentialBlur * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CAIRO_UTILS_TYPE_EXPONENTIAL_BLUR, CairoUtilsExponentialBlur);
	g_signal_handlers_destroy (self);
}


GType cairo_utils_exponential_blur_get_type (void) {
	static volatile gsize cairo_utils_exponential_blur_type_id__volatile = 0;
	if (g_once_init_enter (&cairo_utils_exponential_blur_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { cairo_utils_value_exponential_blur_init, cairo_utils_value_exponential_blur_free_value, cairo_utils_value_exponential_blur_copy_value, cairo_utils_value_exponential_blur_peek_pointer, "p", cairo_utils_value_exponential_blur_collect_value, "p", cairo_utils_value_exponential_blur_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (CairoUtilsExponentialBlurClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cairo_utils_exponential_blur_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CairoUtilsExponentialBlur), 0, (GInstanceInitFunc) cairo_utils_exponential_blur_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType cairo_utils_exponential_blur_type_id;
		cairo_utils_exponential_blur_type_id = g_type_register_fundamental (g_type_fundamental_next (), "CairoUtilsExponentialBlur", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&cairo_utils_exponential_blur_type_id__volatile, cairo_utils_exponential_blur_type_id);
	}
	return cairo_utils_exponential_blur_type_id__volatile;
}


gpointer cairo_utils_exponential_blur_ref (gpointer instance) {
	CairoUtilsExponentialBlur* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void cairo_utils_exponential_blur_unref (gpointer instance) {
	CairoUtilsExponentialBlur* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CAIRO_UTILS_EXPONENTIAL_BLUR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



